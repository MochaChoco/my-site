---
title: 결제 비밀번호 입력을 위한 숫자패드 컴포넌트 개발 과정
description: "금융 서비스에서 사용되는 확장 가능한 숫자패드 컴포넌트를 개발하면서 고민했던 설계 방식과 UX 개선 사항을 공유합니다."
date: "2025-01-08"
tags: ["react", "ux", "components"]
slug: "custom-numpad-component"
coverImage: "/images/posts/custom-numpad-component/cover.png"
---

![커버 이미지](/images/posts/custom-numpad-component/cover.png)

금융 서비스 프론트엔드 프로젝트에서 진행했던 카드 등록 페이지 개선 경험을 정리해보려고 합니다. 특히 커스텀 숫자패드 컴포넌트를 어떻게 확장했고, 사용자 경험을 어떤 방향으로 다듬었는지에 집중해서 공유합니다.

## 문제의식과 배경

온라인 결제 서비스에서 카드 등록은 사용자가 가장 민감하게 정보를 입력하는 단계 중 하나입니다. 카드 번호, 유효기간, CVC, 카드 비밀번호 등 다양한 숫자 정보를 정확하고 안전하게 입력받는 것이 중요하죠. 특히 모바일 환경에서는 시스템 키보드 대신 커스텀 숫자패드(numpad)를 제공해, 일관되고 직관적인 입력 경험을 만들곤 합니다.

저희 팀은 기존 카드 등록 페이지의 입력 편의성을 높이는 것과 동시에, `결제 비밀번호`라는 새로운 인증 수단을 도입해야 했습니다. 단순히 숫자만 입력받던 기존 숫자패드 컴포넌트를 여러 시나리오에 대응하도록 확장하면서, 보안과 사용성 둘 다 놓치지 않는 설계가 필요했습니다.

핵심 고민은 다음과 같았습니다.

1.  **숫자패드의 재사용성**: 여러 입력 필드(CVC, 카드 비밀번호)와 새로 추가될 결제 비밀번호 입력까지, 하나의 숫자패드 컴포넌트로 모두 대응할 수 있을까?
2.  **UI/UX 개선**: 필드별로 다른 입력 길이, 마스킹 처리, 자동 포커스 이동 등을 어떻게 자연스럽게 구현할까?
3.  **결제 비밀번호 흐름**: 카드 등록 후 결제 비밀번호를 입력받는 완전히 새로운 모드를 어떻게 숫자패드에 통합할까?

이 문제를 풀기 위해 숫자패드를 단순 입력 도구가 아니라, 결제 정보 입력 전반을 안정적으로 받쳐주는 핵심 UI로 보도록 방향을 잡았습니다.

## 핵심 개념 파고들기: 숫자패드와 입력 필드의 유기적 연동

카드 등록 페이지는 사용자가 카드 정보를 입력하고 결제 비밀번호를 설정하는 전체적인 흐름을 제어하는 진입점입니다. 이 페이지에서는 `CardNumberInput`, `DefaultInput`과 같은 입력 필드 컴포넌트와 `CustomNumpad` 컴포넌트가 유기적으로 연동되어 동작합니다.

사용자가 카드 등록 페이지에 진입하면, 먼저 카드 번호, 유효기간, CVC, 카드 비밀번호를 입력하게 됩니다. 여기서 카드 번호는 일반적인 키보드 입력을 지원하지만, 유효기간, CVC, 카드 비밀번호는 커스텀 숫자패드를 통해 입력받도록 설계되었습니다. 각 입력 필드를 클릭하면 해당 필드의 요구사항(예: 최대 길이, 입력 값을 업데이트할 함수)에 맞춰 숫자패드가 열리고, 사용자가 숫자를 입력하면 실시간으로 필드 값이 업데이트됩니다.

모든 카드 정보 입력이 완료되고 "등록하기" 버튼을 클릭하면, 커스텀 숫자패드는 "결제 비밀번호" 입력 모드로 전환됩니다. 이 모드에서는 6자리의 결제 비밀번호를 입력받고, UI 또한 비밀번호 입력에 특화된 형태로 변경됩니다. 비밀번호 입력이 완료되면 숫자패드는 자동으로 닫히고, 적절한 후속 로직(예: 모달 표시)이 실행됩니다. 이러한 복잡한 상태 관리와 UI 연동을 위해 React 훅과 상태 관리 라이브러리, 그리고 SCSS 모듈화를 적극적으로 활용했습니다.

### React 훅으로 구현하는 동적인 UI

React 함수형 컴포넌트에서 상태와 사이드 이펙트를 다루려면 `useState`, `useMemo`, `useRef`, `useEffect`, `useCallback` 같은 훅(Hook)이 사실상 필수입니다. 저희는 이 훅들을 조합해 숫자패드와 입력 필드 사이의 상호작용을 정리했습니다.

- **`useState`**: 숫자패드의 `open` 여부, 내부의 `inputValue` 값, 그리고 각 입력 필드(`cardNumber`, `expiryDate`, `cvc`, `cardPassword`, `paymentPassword`)의 값들을 `useState`로 관리했습니다. `mode`와 `maxLength`, `updateFunc` 같은 숫자패드의 동작을 제어하는 상태들도 모두 `useState`로 정의되어, 사용자 인터랙션에 따라 동적으로 속성을 변경할 수 있었습니다.
- **`useMemo`**: 성능 최적화를 위해 `useMemo`를 적극적으로 활용했습니다. 예를 들어, "등록하기" 버튼의 활성화 여부를 결정하는 `isValid` 상태는 여러 입력 필드의 유효성을 모두 검사하는 비교적 비용이 드는 연산입니다. 이를 `useMemo`로 감싸 의존성 배열에 있는 값들이 변경될 때만 다시 계산하도록 하여 불필요한 재연산을 방지했습니다. 또한, 카드 번호의 일부를 마스킹 처리할 때 사용되는 값들도 `useMemo`를 통해 효율적으로 관리했습니다.
- **`useRef`**: 카드 번호 입력 컴포넌트에서 4자리씩 입력할 때, 다음 입력 필드로 자동으로 포커스를 이동시키기 위해 `useRef`를 사용했습니다. 각 `<input>` 요소에 직접 접근하여 `.focus()` 메서드를 호출함으로써 사용자 편의성을 크게 향상시킬 수 있었습니다.
- **`useEffect`**: 컴포넌트 렌더링 이후에 발생하는 부수 효과들은 `useEffect`로 관리했습니다. 숫자패드가 열릴 때마다 숫자 버튼의 배열을 무작위로 섞는 함수를 `useEffect` 내부에서 호출했고, 비밀번호 길이가 6자리에 도달하면 자동으로 모달을 띄우는 로직도 `useEffect`를 통해 구현했습니다. 또한 카드 번호의 변화를 감지하여 카드 회사 정보를 업데이트하는 로직도 `useEffect` 내에서 호출되었습니다.
- **`useCallback`**: 자식 컴포넌트에 props로 내려가는 함수가 매 렌더마다 새로 만들어지는 일을 줄이기 위해 `useCallback`을 사용했습니다. 특히 숫자 배열을 섞는 로직처럼 의존성이 명확한 함수는 `useCallback`으로 고정해두면, 불필요한 렌더링과 계산을 줄이는 데 도움이 됩니다.

### 스타일링과 전역 상태 관리

UI/UX 개선을 위해 스타일링과 전역 상태 관리도 중요하게 다루었습니다.

- **CSS Modules & SCSS Mixins/Variables**: 컴포넌트별 스타일 충돌을 방지하고 유지보수성을 높이기 위해 CSS Modules를 사용했습니다. 또한, SCSS의 `Mixins`와 `Variables`를 활용하여 타이포그래피 스타일이나 색상 변수들을 중앙에서 관리하여 디자인 시스템의 일관성을 확보하고 생산성을 높였습니다.
- **전역 상태 관리**: 비밀번호 재설정 기능이나 입력 완료 시 모달을 띄우는 등 전역적으로 관리되어야 하는 UI 상태는 상태 관리 라이브러리를 활용하여 관리했습니다. 이는 컴포넌트 트리의 깊이에 상관없이 모달 상태를 쉽게 제어할 수 있게 해주었습니다.
- **반응형 대응**: 모바일 환경에 맞춰 현재 화면 크기/기기 타입을 판단하는 커스텀 훅을 두고, 상황에 따라 숫자 버튼의 열 개수를 동적으로 바꿨습니다.

이런 선택들을 쌓아, 숫자패드가 단순 입력기를 넘어 결제 플로우에 맞춘 UI로 자연스럽게 동작하도록 만들었습니다.

## 구현 포인트: 코드와 함께 자세히 보기

### 1. 숫자패드 컴포넌트의 기능 확장 및 모드 추가

숫자패드 컴포넌트는 이번 작업의 중심이었습니다. 기존에는 일반 숫자 입력만 담당했지만, 결제 비밀번호 입력을 위해 `mode` prop을 추가해 `default`/`payment` 두 가지 모드로 동작하도록 확장했습니다. `payment` 모드에서는 비밀번호 입력에 맞춘 UI를 별도로 제공합니다.

보안 측면에서 중요한 기능 중 하나는 **숫자 버튼의 무작위 배치**입니다. `sort` prop을 활성화하면 숫자패드가 열릴 때마다 0-9 숫자 버튼의 위치가 랜덤하게 섞입니다. 키로깅(keylogging) 공격은 사용자의 입력/클릭 패턴을 기록해 비밀번호를 유추하는데, 매번 숫자 위치가 바뀌면 클릭 좌표만으로는 값이 바로 대응되지 않습니다. 금융권 앱에서 흔히 쓰이는 방식이기도 합니다.

```tsx
// 커스텀 숫자패드 컴포넌트
import { useCallback, useEffect, useState } from "react";
import styles from "./CustomNumpad.module.scss";
import BackspaceIcon from "@/components/icons/BackspaceIcon";
import MaskedPasswordIcon from "@/components/icons/MaskedPasswordIcon";
import ArrowRightIcon from "@/components/icons/ArrowRightIcon";
import { useModalStore } from "@/store/modalStore";

// 숫자패드 컴포넌트의 Props 타입 정의
type CustomNumpadProps = {
  open: boolean; // 숫자패드 표시 여부
  setOpen: React.Dispatch<React.SetStateAction<boolean>>; // 숫자패드 표시 상태 변경 함수
  rows: 3 | 4; // 숫자 버튼 행 개수 (3열 또는 4열)
  sort: boolean; // 숫자 무작위 정렬 여부 (보안 강화)
  maxLength: number; // 입력 최대 길이 (CVC: 3자리, 카드 비밀번호: 2자리, 결제 비밀번호: 6자리)
  mode?: "default" | "payment"; // 일반 모드 또는 결제 비밀번호 모드
  updateFunc: React.Dispatch<React.SetStateAction<string>> | null; // 상위 컴포넌트 상태 업데이트 함수
};

export default function CustomNumpad({
  open,
  setOpen,
  rows,
  sort,
  maxLength,
  mode = "default",
  updateFunc = null,
}: CustomNumpadProps) {
  // 전역 모달 상태 관리
  const modalStore = useModalStore();

  // 0-9 숫자 배열 생성 (무작위 정렬을 위한 상태)
  const [numberArray, setNumberArray] = useState(
    Array.from({ length: 10 }, (_, i) => i)
  );
  // 현재 숫자패드에 입력된 값 (내부 상태)
  const [inputValue, setInputValue] = useState("");

  // 숫자 버튼 무작위 정렬 함수 (보안 강화)
  const shuffleNumbers = useCallback(() => {
    if (sort) {
      setNumberArray((prev) => [...prev].sort(() => Math.random() - 0.5));
    }
  }, [sort]);

  // 숫자패드 열림/닫힘 상태 변화 감지
  useEffect(() => {
    if (open) {
      shuffleNumbers(); // 열릴 때마다 숫자 순서 섞기
    } else {
      setInputValue(""); // 닫힐 때 입력값 초기화
    }
  }, [open, shuffleNumbers]);

  // 배경(오버레이) 클릭 시 숫자패드 닫기
  function handleClose(e: React.MouseEvent<HTMLDivElement>) {
    if (e.target === e.currentTarget) {
      setOpen(false);
    }
  }

  // 숫자 버튼 클릭 시 입력 처리
  function handleInput(num: number) {
    if (updateFunc) {
      // 최대 길이 초과 방지
      if (inputValue.length >= maxLength) return;

      // 내부 상태 및 상위 컴포넌트 상태 업데이트
      setInputValue((prev) => prev + num.toString());
      updateFunc((prev) => prev + num.toString());

      // 최대 길이 도달 시 자동으로 숫자패드 닫기
      if (inputValue.length + 1 === maxLength) setOpen(false);
    }
  }

  // 백스페이스 기능: 마지막 한 글자 삭제
  function handleDelete() {
    setInputValue((prev) => prev.slice(0, -1));
    if (updateFunc) updateFunc((prev) => prev.slice(0, -1));
  }

  // 전체 삭제 버튼: 입력된 모든 값 초기화
  function handleDeleteAll() {
    setInputValue("");
    if (updateFunc) updateFunc("");
  }

  // 비밀번호 재설정 버튼 클릭 처리 (결제 비밀번호 모드에서만 표시)
  function handleResetPassword() {
    modalStore.setModalStatus({
      open: true,
      desc: "기능 구현 예정입니다.",
      onConfirm: () => {},
    });
  }

  return (
    <div
      className={`${styles["container"]} ${open ? styles["opened"] : ""}
      ${styles[`rows-${rows}`]}
      ${mode === "payment" ? styles["payment-mode"] : ""}
      `}
      onClick={handleClose}
    >
      {/* 결제 비밀번호 모드일 때만 표시되는 헤더 */}
      {mode === "payment" && (
        <div className={styles["header"]}>
          <p className={styles["title"]}>비밀번호 입력</p>
          <p className={styles["text"]}>새로운 비밀번호를 입력해 주세요.</p>
          {/* 마스킹된 비밀번호 입력 상태 표시 (6자리) */}
          <div className={styles["masked-input"]}>
            {Array.from({ length: 6 }, (_, index) => (
              <MaskedPasswordIcon
                key={index}
                filled={index < inputValue.length}
              />
            ))}
          </div>
          <button className={styles["reset-btn"]} onClick={handleResetPassword}>
            <span>비밀번호 재설정</span>
            <ArrowRightIcon />
          </button>
        </div>
      )}
      {/* 숫자 버튼 영역 */}
      <div className={styles["numpad"]}>
        <div className={styles["button-grid"]}>
          {/* 0-9 숫자 버튼 */}
          {numberArray.map((num, index) => (
            <button key={index} onClick={() => handleInput(num)}>
              <span className={styles["number"]}>{num}</span>
            </button>
          ))}
          {/* 전체 삭제 버튼 */}
          <button
            className={`${styles["action-btn"]} ${styles["left"]}`}
            onClick={handleDeleteAll}
          >
            <span className={styles["number"]}>전체 삭제</span>
          </button>
          {/* 한 글자 삭제 버튼 */}
          <button
            className={`${styles["action-btn"]} ${styles["right"]}`}
            onClick={handleDelete}
          >
            <span className={styles["number"]}>
              <BackspaceIcon />
            </span>
          </button>
        </div>
      </div>
    </div>
  );
}
```

```scss
/* 커스텀 숫자패드 스타일 */
.container {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100dvh;
  display: flex;
  flex-direction: column-reverse; // 기본적으로 버튼이 하단에 위치
  z-index: 5;
  bottom: -100%; // 초기 상태는 화면 밖
  transition: bottom 0.2s ease-out; // 부드러운 슬라이드 애니메이션

  // 열린 상태
  &.opened {
    bottom: 0;
  }

  // 결제 비밀번호 모드
  &.payment-mode {
    flex-direction: column; // 헤더가 상단, 버튼이 하단
    height: 100dvh;
    .header {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: var(--color-white);

      .title {
        font-size: 24px;
        font-weight: bold;
        color: var(--color-primary);
      }

      .text {
        font-size: 14px;
        color: var(--color-secondary);
        margin-top: 16px;
      }

      // 마스킹된 비밀번호 표시 영역
      .masked-input {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 16px;
        margin-top: 64px;
      }

      // 비밀번호 재설정 버튼
      .reset-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 12px 8px 12px 12px;
        margin-top: 48px;
        span {
          font-size: 14px;
          font-weight: bold;
          color: var(--color-secondary);
        }
      }
    }
  }

  // 숫자패드 영역
  .numpad {
    display: flex;
    justify-content: center;
    width: 100%;
    background: var(--color-background);
    padding: 40px 0;
    z-index: 1;
  }
}

// 숫자 버튼 그리드
.button-grid {
  position: relative;
  width: fit-content;
  display: grid;
  justify-content: center;
  align-items: center;

  button {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--color-text);
    font-size: 24px;
    font-weight: bold;
    border-radius: 20px;
    transition: all 0.15s ease-out;

    // 호버 효과 (터치스크린이 아닌 경우만)
    @media (hover: hover) {
      &:active {
        opacity: 0.5;
      }
      &:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }
    }

    // 삭제 버튼들 (전체 삭제, 한 글자 삭제)
    &.action-btn {
      position: absolute;
      bottom: 0;
      font-size: 14px;
      &.left {
        left: 0; // 전체 삭제
      }
      &.right {
        right: 0; // 한 글자 삭제
      }
    }
    // 0 버튼을 가운데 열에 배치
    &:nth-child(10) {
      grid-column: 2;
    }
  }
}

// 3열 레이아웃 (모바일)
.rows-3 {
  .button-grid {
    max-width: 280px;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px 20px;
  }
}

// 4열 레이아웃 (데스크톱)
.rows-4 {
  .button-grid {
    max-width: 332px;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px 4px;

    // 데스크톱에서는 버튼 간격 확대
    @media (min-width: 768px) {
      max-width: 380px;
      gap: 12px 20px;
    }
  }
  button {
    &:nth-child(9) {
      grid-column: 2;
    }
    &:nth-child(10) {
      grid-column: 3;
    }
  }
}
```

위 코드는 커스텀 숫자패드 컴포넌트와 스타일의 핵심 부분을 발췌한 예시입니다.

1.  **`mode` prop 추가 및 조건부 UI 렌더링**: `mode` prop을 `default` 또는 `payment`로 설정할 수 있게 하여, `payment` 모드일 때만 전용 헤더 섹션이 렌더링되도록 했습니다. 이 헤더는 비밀번호 입력 안내, 마스킹된 입력 상태 표시, 그리고 비밀번호 재설정 버튼을 포함합니다.
2.  **다양한 입력 액션 지원**: 한 글자 삭제와 전체 삭제 함수를 추가하여 사용자가 입력 내용을 더욱 유연하게 제어할 수 있도록 했습니다. 이 함수들은 내부 상태뿐만 아니라 업데이트 함수를 통해 외부 입력 필드의 상태도 함께 업데이트합니다.
3.  **스타일 변화**: SCSS에서는 `payment-mode` 셀렉터를 사용하여 결제 모드일 때 레이아웃의 `flex-direction`을 변경하고, 전용 헤더의 스타일을 정의했습니다. 모바일 및 데스크톱 환경에 맞춰 숫자 버튼의 그리드 레이아웃을 동적으로 조절할 수 있게 했습니다.

### 2. 카드 등록 페이지 입력 필드와 숫자패드 연동 개선

카드 등록 페이지 컴포넌트는 여러 입력 필드의 상태를 관리하고, 숫자패드의 열림/닫힘 및 모드를 제어하는 핵심 로직을 담당합니다. 여기서는 각 필드에 맞는 속성을 동적으로 설정하고, 결제 비밀번호 입력 흐름을 시작하는 로직이 구현되어 있습니다.

```tsx
// 카드 등록 페이지
import { useEffect, useMemo, useState } from "react";
import Header from "@/components/common/Header";
import Container from "@/components/common/Container";
import Footer from "@/components/common/Footer";
import styles from "./RegistrationPage.module.scss";
import DefaultInput from "@/components/ui/DefaultInput";
import CardNumberInput from "@/components/ui/CardNumberInput";
import CustomNumpad from "@/components/ui/CustomNumpad";
import { useModalStore } from "@/store/modalStore";
import Button from "@/components/ui/Button";

export default function RegistrationPage() {
  // 전역 모달 상태 관리
  const modalStore = useModalStore();

  // 카드 정보 입력 상태
  const [cardNumber, setCardNumber] = useState<string>("");
  const [cardProvider, setCardProvider] = useState<string>("");
  const [expiryDate, setExpiryDate] = useState<string>("");
  const [cvc, setCvc] = useState<string>("");
  const [cardPassword, setCardPassword] = useState<string>("");
  const [paymentPassword, setPaymentPassword] = useState<string>("");

  // 숫자패드 제어 상태
  const [numpadMode, setNumpadMode] = useState<"default" | "payment">(
    "default"
  );
  const [numpadOpen, setNumpadOpen] = useState<boolean>(false);
  const [numpadMaxLength, setNumpadMaxLength] = useState<number>(4);
  const [updateFunc, setUpdateFunc] = useState<React.Dispatch<
    React.SetStateAction<string>
  > | null>(null);

  // 약관 동의 상태
  const [isAgreed, setIsAgreed] = useState<boolean>(false);

  // 등록 버튼 활성화 여부 (모든 필드 유효성 검사)
  const isValid = useMemo(() => {
    return (
      cardNumber.length >= 13 &&
      cardProvider !== "" &&
      expiryDate.length === 5 &&
      cvc.length === 3 &&
      cardPassword.length === 2 &&
      isAgreed
    );
  }, [cardNumber, cardProvider, expiryDate, cvc, cardPassword, isAgreed]);

  // 결제 비밀번호 6자리 입력 완료 감지
  useEffect(() => {
    if (paymentPassword.length === 6) {
      modalStore.setModalStatus({
        open: true,
        desc: "결제 비밀번호 설정이 완료되었습니다.",
        onConfirm: () => {
          // 서버로 비밀번호 전송 및 저장 (암호화 필수)
        },
      });
    }
  }, [paymentPassword, modalStore]);

  // 유효기간 포맷팅 함수 (MM/YY 형식)
  function formatExpiryDate(value: string): string {
    const digits = value.replace(/\D/g, "");
    const month = digits.substring(0, 2);
    const year = digits.substring(2, 4);

    if (month.length === 0) return "";
    if (month.length < 2) return month;
    if (year.length === 0) return `${month}/`;
    return `${month}/${year}`;
  }

  // CVC 또는 카드 비밀번호 입력을 위한 숫자패드 열기
  function handleNumpadOpen(type: "cvc" | "password") {
    setNumpadMode("default");
    if (type === "cvc") {
      setCvc("");
      setUpdateFunc(() => setCvc);
      setNumpadOpen(true);
      setNumpadMaxLength(3);
    } else if (type === "password") {
      setCardPassword("");
      setUpdateFunc(() => setCardPassword);
      setNumpadOpen(true);
      setNumpadMaxLength(2);
    }
  }

  // 등록 버튼 클릭 시 결제 비밀번호 입력 모드로 전환
  function handleRegister() {
    if (!isValid) return;

    setPaymentPassword("");
    setNumpadMaxLength(6);
    setNumpadOpen(true);
    setNumpadMode("payment");
    setUpdateFunc(() => setPaymentPassword);
  }

  // 약관 동의 체크박스 토글
  const handleAgree = () => {
    setIsAgreed(!isAgreed);
  };

  return (
    <>
      <Header title="카드 등록" closeUrl={-1} />
      <Container>
        <div className={styles["form"]}>
          <CardNumberInput
            value={cardNumber}
            onChange={setCardNumber}
            setProvider={setCardProvider}
          />
          <div className={styles["row"]}>
            <DefaultInput
              label="유효기간"
              value={expiryDate}
              onChange={setExpiryDate}
              uid="expiry"
              type="numeric"
              placeholder="MM/YY"
              onFormat={formatExpiryDate}
              maxLength={5}
            />
            <DefaultInput
              label="CVC"
              value={cvc}
              onChange={setCvc}
              uid="cvc"
              type="password-number"
              placeholder="카드 뒷면 3자리"
              maxLength={3}
              readOnly
              onClick={() => handleNumpadOpen("cvc")}
            />
          </div>
          <DefaultInput
            label="카드 비밀번호"
            value={cardPassword}
            onChange={setCardPassword}
            uid="password"
            type="password-number"
            placeholder="비밀번호 (앞 2자리)"
            maxLength={2}
            readOnly
            onClick={() => handleNumpadOpen("password")}
          />
          <div className={styles["agreement"]}>
            <button onClick={handleAgree}>체크박스</button>
            <ul>
              <li>약관 동의</li>
            </ul>
          </div>
          <Button disabled={!isValid} onClick={handleRegister}>
            등록하기
          </Button>
        </div>
      </Container>
      <Footer />
      <CustomNumpad
        open={numpadOpen}
        setOpen={setNumpadOpen}
        rows={4}
        sort={true}
        maxLength={numpadMaxLength}
        mode={numpadMode}
        updateFunc={updateFunc}
      />
    </>
  );
}
```

이 컴포넌트는 카드 등록 페이지의 전반적인 흐름을 제어합니다.

1.  **다양한 상태 관리**: `useState` 훅을 사용하여 카드 정보와 비밀번호를 개별적으로 관리합니다. 또한 숫자패드의 동작을 제어하는 상태들도 이곳에서 선언됩니다.
2.  **`isValid`를 통한 유효성 검사**: `useMemo`를 사용하여 모든 필수 입력 필드가 유효한지 확인하는 값을 계산합니다. 이 값은 등록 버튼의 활성화/비활성화를 제어하여 사용자가 유효하지 않은 상태에서 등록을 시도하는 것을 방지합니다.
3.  **숫자패드 연동**: 입력 필드의 클릭 핸들러에 함수를 연결했습니다. 이 함수는 클릭된 필드의 종류에 따라 업데이트 함수와 최대 길이를 설정하여 올바른 입력을 받고 해당 필드를 업데이트하도록 합니다.
4.  **결제 비밀번호 모드 전환**: 등록 버튼을 클릭하면 핸들러 함수가 호출됩니다. 이 함수는 모드를 결제 모드로 설정하고 최대 길이를 변경하여 비밀번호 입력 모드로 전환되도록 합니다.
5.  **입력 완료 감지**: 비밀번호 길이가 목표에 도달하면 `useEffect` 훅이 이를 감지하고, 상태 관리 스토어를 통해 사용자에게 안내 모달을 표시합니다.

### 3. 입력 필드 컴포넌트의 유연성 확보 및 마스킹 처리

입력 필드 컴포넌트들은 숫자패드와의 연동 및 보안 요구사항을 충족하기 위해 개선되었습니다. 특히 카드 번호는 분할 입력, 비밀번호는 마스킹 처리 기능이 중요했습니다.

주요 개선 사항:

1. **카드 번호 분할 입력 및 자동 포커스**: 카드 번호를 4자리씩 분할하여 입력받고, `useRef`를 사용하여 다음 입력 필드로 자동 포커스를 이동시키는 로직을 구현했습니다. 백스페이스 시 이전 필드로 포커스를 되돌리는 기능도 추가했습니다.

2. **카드 발급사 자동 식별**: 입력된 카드 번호의 접두사를 기반으로 카드 발급사를 자동으로 식별하여 상태를 업데이트합니다. 이 정보는 사용자에게 시각적 피드백을 제공하여 신뢰도를 높입니다.

3. **`password-number` 타입 추가**: 입력 필드 컴포넌트에 새로운 타입을 추가했습니다. 이 타입은 숫자 입력으로 렌더링되지만, `useMemo`를 통해 입력 값을 `*`로 마스킹 처리하여 보안성을 높였습니다.

4. **숫자패드 연동**: 특정 필드는 `readOnly` 속성을 설정하여 직접 키보드 입력을 막고, 클릭 핸들러를 연결하여 클릭 시에만 숫자패드가 열리도록 강제했습니다.

5. **마스킹 스타일링**: CSS에서 실제 입력 필드를 투명하게 만들고 그 위에 마스킹된 문자를 표시하는 기법을 사용했습니다.

## 적용 결과와 효과

이번 커스텀 숫자패드 컴포넌트의 기능 확장 및 카드 등록 페이지 연동 개선 작업을 통해 다음과 같은 긍정적인 결과를 얻을 수 있었습니다.

<img
  src="/my-site/images/posts/custom-numpad-component/result.gif"
  style={{ width: "180px" }}
/>

1.  **컴포넌트의 재활용성 극대화**: 하나의 숫자패드 컴포넌트가 일반 숫자 입력과 비밀번호 입력까지 다양한 시나리오에 유연하게 대응할 수 있게 되었습니다. `mode` prop을 통한 명확한 역할 분리로 컴포넌트의 응집도를 높였습니다.
2.  **향상된 사용자 경험**:
    - 보안 코드 및 비밀번호 입력 시 자동 호출 및 입력 완료 시 자동 닫힘
    - 카드 번호 입력 시 4자리마다 자동 포커스 이동 및 백스페이스 처리
    - 모바일 환경에 최적화된 반응형 레이아웃
    - 입력된 카드 번호를 기반으로 발급사를 즉시 식별하여 시각적 피드백 제공
3.  **보안 강화**: 마스킹 처리와 숫자 전용 입력으로 민감한 금융 정보 입력의 보안성을 높였습니다. 클라이언트 측에서의 유효성 검사 및 마스킹은 사용자 경험을 향상시키고 즉각적인 피드백을 제공하지만, 모든 민감 정보는 서버로 전송되기 전에 반드시 암호화되거나 토큰화되어야 하며, 서버 측에서 데이터 무결성, 형식 유효성, 그리고 사용자의 접근 권한에 대한 철저한 재검증이 이루어져야 합니다. 특히 비밀번호는 저장 시 해싱 처리를 통해 보안을 강화해야 합니다.
4.  **새로운 입력 흐름의 성공적인 통합**: 기존 카드 정보 입력 흐름과 별개로, 등록 완료 후 결제 비밀번호를 입력받는 새로운 UX를 성공적으로 구현했습니다.

## 배운 점과 다음 단계

이번 작업을 하면서, 범용성과 확장성을 염두에 둔 설계가 얼마나 중요한지 체감했습니다. 처음엔 단순해 보이는 유틸리티 컴포넌트라도 요구사항이 늘어날 가능성을 전제로 `props`로 확장 포인트를 만들어두면, 이후 변경 비용이 확실히 줄어듭니다.

또 React 훅을 어떻게 나누고 연결하느냐에 따라, 복잡한 상태와 사이드 이펙트도 훨씬 명확하게 정리할 수 있다는 걸 확인했습니다. 특히 `useMemo`/`useCallback`을 목적에 맞게 사용하면서 불필요한 재계산과 렌더링을 줄인 경험이 도움이 됐습니다.

물론 개선할 부분도 남아있습니다. 입력 과정에서의 에러 케이스를 더 촘촘히 다루거나, 접근성(Accessibility) 기준에 맞춘 키보드/스크린리더 대응을 보강할 여지가 있습니다. 모바일뿐 아니라 태블릿 등 다양한 화면에서도 자연스럽게 보이도록 반응형 디테일을 더 다듬는 것도 다음 과제로 보고 있습니다.

앞으로도 이런 개선을 쌓아, 사용자가 더 편하고 안전하게 결제할 수 있는 경험을 만드는 데 집중하겠습니다.

---
title: "대용량 엑셀 다운로드: 클라이언트에서 서버로"
description: "클라이언트 기반 엑셀 생성의 한계를 극복하고 SSE를 활용한 서버 사이드 아키텍처로 성능과 사용자 경험을 개선한 경험을 공유합니다."
date: "2025-11-12"
tags: ["react", "performance"]
slug: "excel-download-refectoring"
coverImage: "/images/posts/excel-download-refectoring/cover.png"
---

![커버 이미지](/images/posts/excel-download-refectoring/cover.png)

안녕하세요. 오늘은 내부 어드민 시스템 프로젝트를 진행하며 겪었던 흥미로운 문제 해결 경험과 그 과정에서 얻은 인사이트를 공유하려 합니다. 바로 대용량 데이터를 Excel 파일로 다운로드할 때 발생하는 성능 저하와 사용자 경험(UX) 문제를 어떻게 개선했는지에 대한 이야기입니다.

초기에는 Client-Side에서 지속적으로 API를 call하고 Excel 파일을 다운로드하는 방식을 사용했습니다. 하지만 데이터의 양이 늘어날수록 브라우저가 멈추거나 다운로드 완료까지 기약 없이 기다려야 하는 상황이 빈번하게 발생했습니다. 이는 사용자에게 매우 불편한 경험이었고, 시스템의 안정성에도 문제가 될 수 있었습니다. "언제쯤 다운로드가 완료될까?"라는 질문에 명확한 답변을 줄 수 없다는 점이 가장 큰 문제였죠.

그래서 저희는 이 문제를 해결하기 위해 Client-Side 중심의 처리 방식을 Server-Side로 전환하고, 실시간으로 다운로드 진행 상황을 사용자에게 보여줄 수 있는 SSE(Server-Sent Events) 스트리밍 방식을 도입하기로 결정했습니다. 이 변화가 어떻게 성능과 사용성을 동시에 잡을 수 있었는지 지금부터 자세히 살펴보겠습니다.

## 대용량 데이터, Server-Side로 관리하다: 배경 및 개념 설명

대용량 데이터를 웹 애플리케이션에서 다룰 때 가장 먼저 고려해야 할 것은 `Client-Side`와 `Server-Side`의 역할 분담입니다. 이전 방식에서는 클라이언트가 직접 모든 데이터를 조회하고, 메모리에 적재하여 Excel 파일을 생성했습니다. 하지만 이 방식은 클라이언트의 웹 브라우저가 감당할 수 있는 메모리와 CPU 자원에 한계가 있어 대용량 데이터 처리 시 성능 저하와 멈춤 현상을 유발했습니다. 이를 해결하기 위해 우리는 서버에서 이 모든 작업을 수행하도록 아키텍처를 변경했습니다.

`Next.js API Routes`는 이러한 Server-Side 로직을 구현하기에 아주 적합한 환경을 제공합니다. 클라이언트의 번들 크기를 줄이고, 민감한 비즈니스 로직을 서버에서 안전하게 처리할 수 있다는 장점이 있죠. 저희는 `src/api/export/route.ts` 같은 API Route를 활용하여 백엔드 API처럼 데이터 조회, 가공, 파일 생성 등의 무거운 작업을 서버에서 담당하도록 했습니다.

### 효율적인 데이터 조회를 위한 `페이징 (Pagination)`

대량의 데이터를 한 번에 가져오는 것은 서버에도 큰 부담을 줍니다. 그래서 저희는 `페이징(Pagination)` 기법을 Server-Side 데이터 수집 과정에 적용했습니다. 페이징은 전체 데이터를 여러 개의 작은 페이지로 나누어 필요한 부분만 요청하고 가져오는 방식입니다. 이를 통해 데이터베이스의 부하를 줄이고, 네트워크 트래픽을 효율적으로 관리할 수 있게 됩니다.

예를 들어, 100만 건의 데이터를 한 번에 가져오는 대신, 1,000건씩 1,000번에 걸쳐 나누어 가져오는 것이죠. 이 과정에서 서버는 각 페이지의 데이터를 조회할 때마다 클라이언트에게 진행 상황을 알려줄 수 있습니다.

```javascript
// Server-side conceptual pagination logic (for illustration)
async function fetchDataFromDatabase(pageNumber, pageSize, queryParams) {
  // 실제 데이터베이스 쿼리는 여기에 작성됩니다.
  // 예를 들어, OFFSET과 LIMIT을 사용하여 특정 페이지의 데이터를 가져옵니다.
  const offset = (pageNumber - 1) * pageSize;
  const items = await db.query(
    "SELECT * FROM data_records WHERE ... LIMIT ? OFFSET ?",
    [pageSize, offset],
  );
  const totalCount = await db.query(
    "SELECT COUNT(*) FROM data_records WHERE ...",
  );
  return {
    data: items,
    total: totalCount[0].count,
    currentPage: pageNumber,
    totalPages: Math.ceil(totalCount[0].count / pageSize),
  };
}
```

위 코드는 데이터베이스에서 특정 페이지의 데이터를 가져오는 개념적인 서버 측 페이징 로직을 보여줍니다. `offset`과 `limit`을 사용하여 필요한 범위의 데이터만 효율적으로 조회하는 것이 핵심입니다. 실제 구현에서는 `retrievePagedDataWithProgress`와 같은 함수를 통해 이 로직이 추상화되어 사용됩니다.

### 사용자 경험의 핵심, `Server-Sent Events (SSE)`

대용량 데이터를 다운로드하는 동안 사용자는 진행 상황을 알 수 없어 답답함을 느낄 수 있습니다. 기존 방식에서는 다운로드 완료 알림만 있었기에, 사용자는 브라우저가 멈춘 건지, 아니면 작업이 진행 중인지 알기 어려웠습니다. 이 문제를 해결하기 위해 도입한 것이 바로 `Server-Sent Events (SSE)`입니다.

SSE는 서버가 클라이언트에게 단방향으로 실시간 데이터를 스트리밍할 수 있도록 하는 웹 API입니다. HTTP 프로토콜 위에서 동작하며, 한 번 연결이 수립되면 서버는 데이터를 지속적으로 클라이언트에게 푸시할 수 있습니다. WebSocket과 달리 양방향 통신이 아닌 서버-클라이언트 단방향 통신에 최적화되어 있어, 다운로드 진행률처럼 서버에서 클라이언트로만 정보를 보내는 경우에 특히 효율적입니다.

저희는 서버에서 데이터를 수집하고 Excel 파일을 생성하는 각 단계마다 SSE를 통해 진행률, 현재 처리 중인 페이지, 수집된 아이템 수, 경과 시간 등의 정보를 클라이언트에 실시간으로 전송했습니다. 클라이언트는 이 메시지를 받아 UI에 업데이트함으로써 사용자에게 명확한 피드백을 제공합니다.

```javascript
// Client-side SSE 처리
function ExportProgressMonitor() {
  const [progressMessage, setProgressMessage] = useState("다운로드 준비 중...");
  const [downloadProgress, setDownloadProgress] = useState(0);

  useEffect(() => {
    const eventSource = new EventSource("/api/export-stream");

    eventSource.addEventListener("message", (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "progress") {
        setDownloadProgress(
          Math.floor((data.collectedItems / data.totalItems) * 100),
        );
        setProgressMessage(`${data.message} (${data.collectedItems}개 수집)`);
      } else if (data.type === "complete") {
        setProgressMessage("다운로드 완료!");
        eventSource.close();
      } else if (data.type === "error") {
        alert(data.message);
        eventSource.close();
      }
    });

    return () => eventSource.close();
  }, []);
}
```

이 클라이언트 측 코드는 `EventSource`를 사용하여 서버로부터 SSE 메시지를 수신하고, 메시지 타입에 따라 UI의 진행 상황 텍스트(`progressMessage`)와 진행률 바(`downloadProgress`)를 업데이트하는 방식입니다. 이를 통해 사용자는 현재 다운로드 작업이 어떤 단계에 있는지, 얼마나 진행되었는지를 시각적으로 파악할 수 있게 됩니다.

### 바이너리 데이터 전송을 위한 `Base64 인코딩`과 `Blob`

서버에서 생성된 Excel 파일은 바이너리 데이터입니다. 이 데이터를 HTTP 응답 스트림을 통해 클라이언트에 전달하고 클라이언트에서 파일로 재구성해야 합니다. 이때 `Base64 인코딩`과 `Blob` 객체가 중요한 역할을 합니다.

서버는 생성된 Excel 파일의 바이너리 데이터를 `Base64` 문자열로 인코딩하여 SSE 메시지에 담아 클라이언트에 전송합니다. Base64 인코딩은 바이너리 데이터를 텍스트 기반의 HTTP 통신 채널을 통해 안전하게 전송하기 위한 표준 방식입니다. 다만, 인코딩 과정에서 데이터 크기가 약 33% 증가하는 오버헤드가 발생한다는 점을 고려해야 합니다.

클라이언트는 Base64 인코딩된 문자열을 수신하면 이를 다시 바이너리 데이터로 디코딩한 후 `Blob(Binary Large Object)` 객체를 생성합니다. `Blob`은 브라우저 메모리상에서 불변의 원시 바이너리 데이터를 나타내는 객체로, 이를 통해 JavaScript에서 실제 파일처럼 다룰 수 있습니다. 최종적으로 `URL.createObjectURL()`을 이용해 생성된 Blob 객체의 URL을 획득하고, 가상의 `<a>` 태그를 생성하여 `download` 속성을 부여한 뒤 클릭 이벤트를 강제로 발생시켜 사용자에게 파일을 다운로드시킵니다.

### Excel 파일 생성을 위한 `ExcelJS` 라이브러리

기존에는 `excel4node` 라이브러리를 사용하여 Excel 파일을 생성했습니다. 하지만 이 라이브러리는 대용량 데이터 처리 시 성능상의 제약이 있었고, 복잡한 서식 적용에도 어려움이 있었습니다. 이에 우리는 더 강력하고 유연한 `ExcelJS` 라이브러리로 전환했습니다.

`ExcelJS`는 Node.js와 브라우저 환경에서 Excel 파일을 생성, 읽기, 수정할 수 있는 기능을 제공하며, 특히 대용량 데이터 처리와 복잡한 서식 지정에 강점을 보입니다. 또한, Promise 기반 API를 제공하여 비동기 작업과의 통합이 용이합니다. 이 라이브러리로의 전환을 통해 파일 생성 성능을 향상시키고, 생성 과정 중에도 `sendProgress` 콜백을 통해 진행률을 클라이언트에 전달할 수 있게 되었습니다.

## 구현 포인트: Client-Side 과부하를 넘어서 Server-Side 스트리밍으로

이제 구체적인 코드 예시를 통해 어떻게 이러한 개선이 이루어졌는지 살펴보겠습니다.

### 1. Client-Side 과부하의 흔적 (Before)

이전 방식에서는 클라이언트가 모든 데이터를 페이지 단위로 순차적으로 가져와 `collectedData.current` 배열에 쌓아두었습니다. 모든 데이터 수집이 완료된 후에야 이 데이터를 서버로 다시 보내 Excel 파일을 생성하도록 요청했습니다. 이 과정에서 데이터 양이 많아지면 클라이언트 브라우저의 메모리 사용량이 급증하고, UI가 멈추는 현상이 발생했습니다.

```javascript
// 기존 방식 (Client-Side 처리)
const handleDownloadClick = async (e) => {
  e.preventDefault?.();
  initData();

  let hasNext = true;
  while (hasNext) {
    // 1. 모든 페이지의 데이터를 순차적으로 불러옴
    const { data, hasNext: next } = await requestPageData(
      props.exportType,
      params.current,
    );
    if (data.length > 0) {
      collectedData.current = [...collectedData.current, ...data]; // 2. 클라이언트 메모리에 누적
    }
    hasNext = next;
    params.current.page = (params.current.page || 0) + 1;
  }

  // 3. 모든 데이터를 가져온 후 서버로 전송하여 Excel 생성
  startExportDownload();
};

const startExportDownload = async () => {
  const response = await request(`/api/export?exportType=${props.exportType}`, {
    method: "POST",
    body: { exportData: collectedData.current }, // 클라이언트가 수집한 모든 데이터를 서버로 전달
    responseType: "blob",
  });

  const url = window.URL.createObjectURL(response);
  const link = document.createElement("a");
  link.href = url;
  link.setAttribute(
    "download",
    `${exportConfig[props.exportType].filename}.xlsx`,
  );
  document.body.appendChild(link);
  link.click();
  link.remove();
  window.URL.revokeObjectURL(url);
};
```

위 코드는 기존 Client-Side 처리 방식의 한계를 명확히 보여줍니다.

1.  **순차적 데이터 수집**: `while (hasNext)` 루프를 통해 모든 페이지의 데이터를 서버로부터 가져옵니다. 이 과정 자체는 비동기적이지만, 모든 데이터를 가져와야 다음 단계로 넘어갈 수 있습니다.
2.  **클라이언트 메모리 누적**: `collectedData.current = [...collectedData.current, ...data];` 라인에서 보듯이, 서버로부터 받은 모든 데이터를 클라이언트의 메모리에 쌓아둡니다. 데이터 양이 많아질수록 클라이언트 브라우저의 메모리 사용량이 크게 늘어나 `OutOfMemory` 에러나 브라우저 멈춤 현상이 발생할 수 있었습니다.
3.  **일괄 처리**: 모든 데이터 수집이 완료된 후에야 `startExportDownload()` 함수가 호출되어 Excel 파일 생성 요청이 시작됩니다. 이 때문에 사용자는 데이터 수집 및 파일 생성 과정 동안 아무런 피드백 없이 기다려야 했습니다.
4.  **클라이언트-서버 간 데이터 이중 전송**: 클라이언트가 데이터를 모두 모은 후, 다시 그 모든 데이터를 `body: { exportData: collectedData.current }` 형태로 서버로 전송하는 비효율적인 구조입니다.

이러한 문제점들 때문에 사용자들은 대용량 Excel 다운로드 시 긴 시간 동안 불편함을 감수해야 했고, 저희는 이 문제를 해결하기 위해 아키텍처 개선을 결정했습니다.

### 2. Server-Side 페이징과 SSE 스트리밍으로의 전환 (After)

이제 Server-Side에서 데이터 수집, Excel 생성, 그리고 클라이언트로의 실시간 진행 상황 전송을 담당하는 새로운 로직을 살펴보겠습니다. `src/api/export-stream/route.ts` 파일이 이 역할을 수행합니다.

```typescript
// Server-Side SSE 스트리밍 (핵심 로직)
export async function POST(request: Request) {
  const body = await request.json();
  const params = body.params || {};

  const stream = new ReadableStream({
    async start(controller) {
      const sendProgress = (data: any) => {
        const message = `data: ${JSON.stringify(data)}\n\n`;
        controller.enqueue(new TextEncoder().encode(message));
      };

      try {
        // 1단계: 서버에서 데이터 수집 (페이징 방식)
        sendProgress({
          type: "stage",
          stage: "collecting",
          message: "데이터 수집 중...",
        });

        const exportData = await retrievePagedDataWithProgress(
          exportConfig.dataFetcher,
          params,
          sendProgress, // 진행 상황 콜백 함수
        );

        if (exportData.length === 0) {
          sendProgress({ type: "error", message: "출력할 데이터가 없습니다." });
          controller.close();
          return;
        }

        // 2단계: 서버에서 Excel 파일 생성
        sendProgress({
          type: "stage",
          stage: "generating",
          message: "엑셀 파일 생성 중...",
        });
        await new Promise((resolve) => setImmediate(resolve)); // 이벤트 루프 양보

        const workbookWrapper = generateExportFile(exportType, exportData);
        const buffer = await workbookWrapper.writeToBuffer();
        const base64 = Buffer.from(buffer).toString("base64"); // Base64 인코딩

        // 3단계: 완료 메시지와 함께 파일 데이터 전송
        sendProgress({
          type: "complete",
          message: "다운로드 준비 완료",
          fileData: base64,
          dataType: "excel",
        });
        controller.close();
      } catch (error) {
        sendProgress({
          type: "error",
          message: "다운로드 처리 중 오류가 발생했습니다.",
        });
        controller.close();
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
    },
  });
}
```

핵심 변화:

1.  **SSE 헬퍼 함수**: `sendProgress` 함수가 데이터를 JSON으로 변환하고 `data:` 프리픽스를 붙여 SSE 메시지로 전송합니다.
2.  **Server-Side 페이징**: 데이터를 서버에서 페이징 방식으로 수집하며, 콜백을 통해 진행 상황을 실시간으로 전달합니다.
3.  **이벤트 루프 양보**: `setImmediate`를 활용하여 SSE 메시지가 지연 없이 전달되도록 최적화합니다.
4.  **Base64 인코딩**: 바이너리 Excel 파일을 Base64로 인코딩하여 텍스트 기반 SSE로 전송합니다.

이러한 변화로 클라이언트는 더 이상 대용량 데이터를 메모리에 쌓지 않아도 되며, 실시간 진행 상황을 확인할 수 있게 되었습니다.

### 3. ExcelJS로의 전환과 진행률 콜백 통합

Excel 파일 생성 라이브러리를 `excel4node`에서 `ExcelJS`로 변경하면서, 대용량 파일 처리 성능을 높이고 파일 생성 중에도 진행률을 클라이언트에 전달하는 기능을 추가했습니다.

#### excel4node 대비 ExcelJS의 장점

기존에 사용하던 `excel4node`에서 `ExcelJS`로 전환한 이유는 다음과 같습니다:

<table>
  <thead>
    <tr>
      <th>비교 항목</th>
      <th>excel4node</th>
      <th>ExcelJS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>스트리밍 지원</strong>
      </td>
      <td>미지원</td>
      <td>스트리밍 API로 대용량 파일 메모리 효율적 처리</td>
    </tr>
    <tr>
      <td>
        <strong>비동기 처리</strong>
      </td>
      <td>콜백 기반</td>
      <td>Promise 기반으로 async/await 자연스럽게 통합</td>
    </tr>
    <tr>
      <td>
        <strong>유지보수</strong>
      </td>
      <td>업데이트 중단 (2019년 이후 미활동)</td>
      <td>활발한 커뮤니티와 지속적인 업데이트</td>
    </tr>
    <tr>
      <td>
        <strong>기능 범위</strong>
      </td>
      <td>쓰기 전용</td>
      <td>읽기/쓰기/수정 모두 지원</td>
    </tr>
    <tr>
      <td>
        <strong>서식 지원</strong>
      </td>
      <td>기본적인 서식만 지원</td>
      <td>조건부 서식, 데이터 검증, 이미지 삽입 등 풍부한 기능</td>
    </tr>
    <tr>
      <td>
        <strong>TypeScript</strong>
      </td>
      <td>타입 정의 불완전</td>
      <td>완전한 TypeScript 지원</td>
    </tr>
  </tbody>
</table>

특히 우리 프로젝트에서 중요했던 점은 **Promise 기반 API**와 **스트리밍 지원**이었습니다. `excel4node`의 콜백 기반 API는 SSE 스트리밍과 결합하기 어려웠고, 대용량 데이터 처리 시 전체 워크북을 메모리에 올려야 해서 성능 병목이 발생했습니다. 반면 `ExcelJS`는 `workbook.xlsx.writeBuffer()`와 같은 Promise 기반 메서드를 제공하여 비동기 흐름에 자연스럽게 통합할 수 있었고, 청크 단위로 데이터를 처리하면서 중간 진행률을 전송하는 구조를 쉽게 구현할 수 있었습니다.

```javascript
// ExcelJS를 활용한 Excel 파일 생성
import ExcelJS from "exceljs";

const generateExcelContent = async (data, sendProgress) => {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet("sheet1");

  const chunkSize = 500; // 대용량 데이터 처리를 위한 청크 사이즈
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.slice(i, Math.min(i + chunkSize, data.length));
    chunk.forEach((item, idx) => {
      const row = worksheet.getRow(i + idx + 2);
      // 셀에 데이터 쓰기 로직...
    });

    // 진행률 전송
    const progress = Math.floor(((i + chunk.length) / data.length) * 100);
    if (sendProgress) {
      sendProgress({
        type: "generating_progress",
        progress,
        message: `엑셀 파일 생성 중 (${progress}%)`,
      });
    }
    await new Promise((resolve) => setImmediate(resolve)); // 이벤트 루프 양보
  }

  return { writeToBuffer: async () => await workbook.xlsx.writeBuffer() };
};
```

`ExcelJS`의 주요 개선점:

1.  **청크 기반 처리**: 데이터를 500개씩 나누어 처리하여 메모리 효율성을 높이고 중간 진행률 업데이트가 가능합니다.
2.  **진행률 콜백**: 처리된 데이터 비율을 계산하여 `generating_progress` 메시지로 클라이언트에 전송합니다.
3.  **이벤트 루프 양보**: `setImmediate`로 SSE 메시지가 지연 없이 전달되도록 합니다.

### 4. 다운로드 취소 기능 및 진행률 UI 개선

사용자에게 더 나은 제어권을 제공하고, 애플리케이션의 안정성을 높이기 위해 다운로드 취소 기능을 도입하고 진행률 표시 로직을 개선했습니다.

```javascript
// 다운로드 취소 기능 및 진행률 UI (핵심 로직)
const abortControllerRef = useRef(null);

const initiateExportWithSSE = () => {
  const abortController = new AbortController();
  abortControllerRef.current = abortController;

  fetch(url, {
    method: "POST",
    signal: abortController.signal, // AbortSignal 전달
  }).catch((error) => {
    if (error.name === "AbortError") {
      console.log("Download cancelled by user");
      return;
    }
  });
};

const abortExport = () => {
  if (abortControllerRef.current) {
    abortControllerRef.current.abort(); // fetch 요청 취소
    abortControllerRef.current = null;
  }
};

// UI: 취소 버튼
{
  isLoading && <button onClick={abortExport}>다운로드 취소</button>;
}
```

`AbortController`는 웹 요청을 취소할 수 있게 해주는 표준 Web API입니다. `fetch` 요청에 `signal`을 전달하고, 취소가 필요할 때 `abort()`를 호출하면 됩니다. `AbortError`를 별도로 처리하여 사용자가 의도적으로 취소한 경우와 실제 오류를 구분할 수 있습니다.

## 결과 및 효과: 성능과 사용성을 동시에 잡다

이번 대용량 엑셀 다운로드 기능 개선 프로젝트를 통해 우리는 다음과 같은 의미 있는 성과를 얻을 수 있었습니다.

1.  **클라이언트 부담 대폭 감소**: 가장 큰 문제는 Client-Side에서 발생하는 메모리 과부하 및 CPU 사용량 증가였습니다. Server-Side 페이징과 Excel 파일 생성 로직을 서버로 이관함으로써, 클라이언트는 더 이상 대량의 데이터를 메모리에 유지하거나 무거운 파일 생성 작업을 수행하지 않게 되었습니다. 이는 브라우저 멈춤 현상과 `OutOfMemory` 에러를 효과적으로 해결했습니다.
2.  **응답성 및 사용자 경험 향상**: SSE 스트리밍 도입으로 사용자는 다운로드 과정(데이터 수집, 파일 생성)을 실시간으로 확인할 수 있게 되었습니다. 진행률 바와 단계별 메시지는 불확실한 대기 시간을 의미 있는 피드백으로 바꾸어, 사용자가 다운로드 상태를 명확히 인지하고 더 이상 답답함을 느끼지 않도록 했습니다.
3.  **안정적인 대용량 데이터 처리**: `ExcelJS` 라이브러리로의 전환과 청크 기반 처리, `setImmediate`를 활용한 이벤트 루프 양보 등의 최적화는 수십만 건 이상의 대용량 데이터도 안정적으로 Excel 파일로 생성할 수 있는 기반을 마련했습니다.
4.  **사용자 제어권 강화**: `AbortController`를 활용한 다운로드 취소 기능은 사용자가 원할 때 언제든지 작업을 중단할 수 있게 하여, 불필요한 네트워크 트래픽과 리소스 낭비를 방지하고 사용자에게 더 나은 제어 경험을 제공했습니다.

이번 프로젝트는 단순히 기술적인 문제 해결을 넘어, 사용자의 불편함을 적극적으로 해소하고 시스템의 전반적인 품질을 향상시켰다는 점에서 큰 의미가 있습니다.

## 배운 점

대용량 데이터 처리는 언제나 개발자에게 큰 도전 과제입니다. 이번 프로젝트를 통해 데이터 처리 로직을 Client-Side와 Server-Side 중 어디에 두어야 할지, 그리고 비동기 통신 방식을 어떻게 선택해야 할지에 대한 중요한 교훈을 얻었습니다.

특히, `SSE`와 `ReadableStream`을 활용한 실시간 스트리밍 경험은 단순한 기능 구현을 넘어, 사용자에게 **"기다림"을 "인지 가능한 진행 과정"으로 변화시키는** 것이 얼마나 중요한지 다시 한번 깨닫게 해주었습니다. 또한 `Base64` 인코딩의 오버헤드나 `setImmediate`와 같은 세부적인 최적화 기법을 적용하며 성능 튜닝에 대한 깊이 있는 이해를 할 수 있었습니다.

앞으로도 사용자 중심의 사고방식과 견고한 아키텍처 설계를 바탕으로 더 나은 서비스를 만들어나가기 위해 노력할 것입니다.

## 참고 자료

- [MDN Web Docs - Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-Sent_Events)
- [Next.js Documentation - Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
- [ExcelJS GitHub Repository](https://github.com/exceljs/exceljs)

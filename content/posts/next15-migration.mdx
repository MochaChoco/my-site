---
title: "Next.js 15 App Router 마이그레이션 여정"
description: "Express 서버와 Page Router로 구성된 레거시 프로젝트를 Next.js 15 App Router 기반으로 전환한 대규모 마이그레이션 경험을 공유합니다."
date: "2025-01-03"
tags: ["react", "maintenance"]
slug: "next15-migration"
coverImage: "/images/posts/next15-migration/cover.png"
---

![커버 이미지](/images/posts/next15-migration/cover.png)

안녕하세요, 이번 글에서는 약 한 달간 진행된 대규모 마이그레이션 경험을 공유하고자 합니다. 기존 Express.js 기반의 레거시 서버를 최신 Next.js 15 App Router 기반으로 전환하면서 겪었던 과정과 그 결과에 대해 자세히 이야기해보려 합니다.

초기 프로젝트는 Next.js Page Router와 함께 Express.js 서버가 백엔드 API와의 통신을 중계하는 모놀리식 구조로 운영되고 있었습니다. 이 구조는 시간이 지남에 따라 몇 가지 문제점을 드러냈습니다. 첫째, Express 서버와 Next.js 애플리케이션이 분리되어 있어 개발 및 배포 환경 설정이 복잡했습니다. 둘째, 클라이언트에서 API를 호출할 때 Express 서버를 거쳐 백엔드로 전달하는 방식은 추가적인 오버헤드를 발생시켰고, 통합된 로깅이나 에러 처리가 어려웠습니다. 마지막으로, 사용자 인증 정보 관리가 클라이언트 사이드에서 주로 이루어져 초기 로딩 성능 저하와 보안 취약성 우려가 있었습니다.

이러한 문제들을 해결하고 애플리케이션의 성능, 유지보수성, 개발 편의성을 대폭 개선하기 위해 Next.js 15 App Router로의 마이그레이션을 결정했습니다. 목표는 기존 Express 서버를 완전히 제거하고, Next.js의 통합된 서버-클라이언트 아키텍처를 최대한 활용하여 단일 프레임워크 기반의 효율적인 개발 환경을 구축하는 것이었습니다.

---

## 새로운 아키텍처, Next.js App Router와 React Server Components

이번 마이그레이션의 핵심은 Next.js App Router의 도입입니다. 기존 `pages` 디렉토리 기반의 Page Router에서 `app` 디렉토리 기반의 App Router로 전환하는 것은 단순히 파일 구조를 바꾸는 것을 넘어, React의 최신 기능인 Server Components (RSC)와 Suspense를 활용하는 근본적인 아키텍처 변화를 의미합니다.

**Next.js App Router**는 파일 시스템 기반 라우터로, `app` 디렉토리 내의 `layout.js`, `page.js`, `route.js`와 같은 특별한 파일 규칙을 통해 애플리케이션의 구조와 라우팅을 정의합니다. 이를 통해 개발자는 서버와 클라이언트 환경 모두에서 코드를 실행하며 다음과 같은 이점을 얻을 수 있습니다.

- **성능 최적화**: 서버 컴포넌트를 사용하여 초기 로딩 시 클라이언트 번들 크기를 줄이고, 데이터를 서버에서 미리 페칭하여 클라이언트로 전송함으로써 더 빠른 페이지 로딩을 가능하게 합니다.
- **개발 경험 향상**: 서버와 클라이언트 로직을 한 곳에서 관리할 수 있어 개발의 복잡성을 줄이고, 데이터 페칭 및 상태 관리가 간소화됩니다.
- **보안 강화**: 민감한 데이터 처리 로직을 서버 컴포넌트 내에 유지할 수 있어 보안성이 향상됩니다.

저희는 App Router의 이러한 이점을 활용하여 기존 시스템의 진입점과 데이터 페칭 방식을 완전히 변경했습니다. 이전에는 `server.js` (Express 서버)와 `pages/_app.js` (Next.js Page Router)가 진입점이었지만, 이제는 모든 요청이 `middleware.ts`를 거쳐 `app/layout.js` (Root Layout)로 흐르게 됩니다.

**React Server Components (RSC)**는 클라이언트 측 자바스크립트 번들 크기를 줄이고 초기 페이지 로딩 성능을 향상시키기 위해 서버에서 렌더링되는 React 컴포넌트입니다. `app` 디렉토리 내의 모든 컴포넌트는 기본적으로 서버 컴포넌트로 간주되며, `useEffect`나 `useState`와 같은 클라이언트 전용 훅을 사용할 수 없습니다. 클라이언트 전용 기능을 사용해야 할 때는 파일 상단에 `"use client"` 지시어를 추가하여 클라이언트 컴포넌트로 명시해야 합니다.

예를 들어, 애플리케이션의 `app/layout.js`는 Root Layout으로 작동하는 서버 컴포넌트입니다. 여기서 `fetchUserDetail` 함수를 통해 사용자 인증 정보를 서버 사이드에서 미리 가져와서 UI 렌더링에 필요한 데이터를 확보합니다. 이렇게 서버에서 데이터를 페칭하고 렌더링한 후, 최소한의 자바스크립트와 함께 HTML을 클라이언트로 전송하여 초기 로딩 속도를 극대화했습니다.

```javascript
// app/layout.js (Root Layout - 서버 컴포넌트)
import "@/public/reset.scss"; // 전역 스타일 임포트
import "@/public/style.scss"; // 전역 스타일 임포트
import Head from "next/head";
import { fetchUserDetail } from "app/api/user/auth/route"; // 서버 사이드에서 사용자 정보 API 호출
import UserSessionProvider from "providers/UserSessionProvider"; // React Context 기반 사용자 세션 프로바이더

export default async function RootLayout({ children }) {
  let userName = "";
  let userId = "";
  let userRoles = [];
  let errorMessage = ""; // 사용자에게 보여줄 에러 또는 안내 메시지

  try {
    const userInfo = await fetchUserDetail(); // 서버에서 사용자 정보 비동기 페칭

    userName = userInfo.name;
    userId = userInfo.id;
    userRoles = userInfo.roles;

    // 사용자 역할 또는 활성화 상태에 따른 접근 권한 확인
    if (!userRoles || userRoles.length === 0 || userRoles[0] === "GUEST") {
      errorMessage = "접근 권한이 없습니다. 관리자에게 문의하세요.";
      // 여기서는 UI 렌더링을 중단하고 메시지를 표시할 수 있음
    }
    if (!userInfo.isActive) {
      errorMessage = "해당 계정은 비활성화 상태입니다. 관리자에게 문의하세요.";
    }
  } catch (error) {
    errorMessage = "로그인 정보가 올바르지 않습니다. 다시 로그인 해주세요.";
    console.error("사용자 정보 페칭 오류:", error);
  }

  return (
    <html lang="ko">
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>애플리케이션 제목</title>
      </Head>
      <body style={{ filter: errorMessage ? "blur(3px)" : "none" }}>
        {/* 에러 발생 시 UI 블러 처리 */}
        <UserSessionProvider
          userName={userName}
          userId={userId}
          userRoles={userRoles}
          error={errorMessage} // 에러 메시지를 Context Provider에 전달
        >
          <AppNavigation />
          {/* AppNavigation은 UserSessionProvider의 상태를 소비 */}
          {children}
        </UserSessionProvider>
      </body>
    </html>
  );
}
```

위 코드는 Next.js App Router의 `RootLayout` 파일입니다. 이 파일은 서버 컴포넌트로 동작하며, 애플리케이션의 최상위 UI 구조를 정의합니다. `fetchUserDetail` 함수를 호출하여 사용자 정보를 서버 사이드에서 비동기적으로 가져오는 것을 볼 수 있습니다. 이 과정에서 사용자 역할이나 활성화 상태를 확인하여 접근 권한이 없는 경우 `errorMessage`를 설정하고, 이 메시지에 따라 UI를 블러 처리하는 등의 시각적인 피드백을 제공합니다. `UserSessionProvider`는 서버에서 가져온 사용자 정보를 클라이언트 컴포넌트에서도 쉽게 접근할 수 있도록 React Context API를 활용하여 전역 상태를 관리하는 역할을 합니다. 이처럼 서버 컴포넌트를 활용함으로써 초기 로딩 시 필요한 데이터를 미리 확보하고, 보안에 민감한 로직을 서버에 유지할 수 있게 됩니다.

---

## API 계층 현대화: Next.js API Route Handler로 전환

기존 Express 서버는 클라이언트의 API 요청을 받아 백엔드 API 서비스로 포워딩하는 역할을 했습니다. 이 방식은 Express 서버가 항상 실행되고 있어야 하고, API 호출 로직이 Next.js 애플리케이션과 분리되어 있어 관리상의 비효율성이 있었습니다. 저희는 이를 Next.js 15 App Router의 **API Route Handler**로 전환하여 API 계층을 현대화했습니다.

**API Route Handler**는 `app/api` 디렉토리 내에 정의되는 특별한 서버리스 함수입니다. 클라이언트가 `/api` 경로로 요청을 보내면, Next.js는 해당 경로에 매칭되는 Route Handler를 실행하여 백엔드 로직을 처리합니다. 이는 기존 Express 라우트의 역할을 대체하며, Next.js 애플리케이션 내에서 API 요청 처리를 통합할 수 있게 해줍니다.

마이그레이션 과정에서 기존 Express 서버의 `server.js` 파일과 `api/` 디렉토리 내의 모든 파일(예: `routes.js`, `user/userRoutes.js`, `data/dataRoutes.js` 등)을 완전히 제거했습니다. 대신, 각 백엔드 API 엔드포인트에 대응하는 Next.js API Route Handler를 `app/api` 디렉토리 내에 생성했습니다.

이를 통해 얻은 이점은 다음과 같습니다:

- **단일화된 개발 스택**: Express 서버를 별도로 관리할 필요 없이 Next.js 하나로 전체 애플리케이션을 개발하고 배포할 수 있습니다.
- **간소화된 API 호출**: 클라이언트에서 백엔드로 직접 API를 호출하는 대신, Next.js 서버를 거쳐 호출하게 하여 보안을 강화하고 일관된 API 호출 패턴을 유지할 수 있습니다.
- **공통 로직 재사용**: `apiFetcher` 및 `apiResponseHandler`와 같은 유틸리티 함수를 도입하여 백엔드 API 호출, 로깅, 에러 처리, 쿠키 전달 등 공통 로직을 표준화하고 재사용성을 높였습니다.

아래 코드는 기존 Express 기반 API 엔드포인트와 이를 Next.js API Route Handler로 전환한 비교 예시입니다.

```javascript
// Before: routes.js (Express GET 라우트 - 데이터 목록 조회)
const express = require("express");
const httpClient = require("axios"); // HTTP 클라이언트
const API_BASE_URL = process.env.API_SERVER_URL; // 백엔드 API URL

const app = express(); // Express 인스턴스
// ... 미들웨어 설정 ...

app.get("/api/data/list", (req, res) => {
  // Express GET 라우트
  let queryParams = req.query; // 요청 쿼리 파라미터
  httpClient
    .get(`${API_BASE_URL}/data/list`, {
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        cookie: req.headers.cookie, // 클라이언트 쿠키 전달
      },
      params: queryParams,
    })
    .then((response) => {
      // ... 응답 데이터 가공 로직 ...
      return res
        .status(200)
        .send({
          data: response.data.items,
          hasMore: response.data.hasMore,
        })
        .end();
    })
    .catch(function (error) {
      console.error("데이터 조회 오류:", error);
      res.status(500).json({ message: "서버 내부 오류 발생" });
    });
});
// ... 유사한 Express GET/POST 라우트 다수 ...
```

이전에는 위와 같이 Express 서버 내에서 `/api/data/list`와 같은 라우트를 정의하고, `httpClient` (axios)를 사용하여 실제 백엔드 API를 호출했습니다. 이때 클라이언트로부터 받은 쿠키와 쿼리 파라미터 등을 직접 전달하는 방식이었습니다. 각 API 엔드포인트마다 이러한 반복적인 로직이 존재하여 유지보수가 번거로웠습니다.

```typescript
// After: app/api/data/list/logic.ts (서버 사이드 로직)
import { apiFetcher } from "@/libs/api/utils"; // 공통 API 페처 유틸리티 임포트

const API_ENDPOINT = `/data/list`; // 실제 백엔드 API 경로

export async function fetchDataList(queryParams: {
  [key: string]: string | string[];
}) {
  const searchParams = new URLSearchParams(
    queryParams as Record<string, string>
  ).toString(); // 쿼리 파라미터 변환

  const response = await apiFetcher(`${API_ENDPOINT}?${searchParams}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  });

  return response; // 백엔드 응답을 직접 반환
}

// After: app/api/data/list/route.ts (Next.js Route Handler)
import { apiResponseHandler } from "@/libs/api/utils"; // Route Handler 응답 유틸리티 임포트
import { fetchDataList } from "./logic"; // 실제 비즈니스 로직 함수 임포트

export const GET = apiResponseHandler<null, any>(async (request: Request) => {
  const { searchParams } = new URL(request.url); // 요청 URL에서 쿼리 파라미터 추출
  const queryParams: { [key: string]: string } = {};
  searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });

  const result = await fetchDataList(queryParams); // 로직 함수 호출
  return result; // JSON 응답 (apiResponseHandler에 의해 포맷팅 및 에러 처리됨)
});
```

마이그레이션 후에는 Next.js App Router의 Route Handler 패턴을 따릅니다. 먼저 `logic.ts` 파일에서 백엔드 API 호출을 담당하는 `fetchDataList` 함수를 정의했습니다. 이 함수는 `apiFetcher`라는 공통 유틸리티를 사용하여 실제 API 요청을 수행하고, 일관된 방식으로 헤더와 에러 처리를 담당합니다. `route.ts` 파일은 실제 Next.js Route Handler로, 클라이언트의 GET 요청을 받으면 `request` 객체에서 쿼리 파라미터를 추출하여 `fetchDataList` 함수에 전달합니다. `apiResponseHandler` 유틸리티는 응답을 적절히 포맷하고 발생할 수 있는 에러를 처리하여 클라이언트에게 최종 JSON 응답을 보냅니다. 이러한 분리를 통해 비즈니스 로직과 API 라우팅 로직을 명확히 구분하고, 공통 로직을 추상화하여 코드의 재사용성과 유지보수성을 크게 향상시켰습니다.

---

## SSR 기반 사용자 인증 및 전역 상태 관리 개선

기존 시스템에서는 사용자 인증 및 권한 확인 로직이 `pages/_app.js`에서 클라이언트 사이드(`componentDidMount`)에 `httpClient` (axios)를 통해 API를 호출하여 처리되었습니다. 이 방식은 사용자가 페이지에 접근하기 전에 클라이언트에서 API 응답을 기다려야 했으므로 초기 로딩 시간이 길어지고, MobX 스토어를 사용하여 사용자 정보를 전역 관리하는 방식은 Next.js의 SSR(Server-Side Rendering) 환경과 잘 맞지 않는 부분이 있었습니다.

저희는 이를 개선하기 위해 사용자 인증 및 권한 확인 로직을 Next.js의 서버 컴포넌트인 `app/layout.js`로 옮겨 SSR 시점에 미리 데이터를 페칭하도록 변경했습니다. 또한, MobX 스토어 대신 React의 내장 기능인 Context API를 활용한 `UserSessionProvider`를 도입하여 전역 상태 관리 방식을 현대화했습니다.

이러한 변경을 통해 다음과 같은 이점을 얻었습니다:

- **초기 로딩 성능 향상**: 서버 사이드에서 사용자 정보를 미리 페칭하므로, 클라이언트가 페이지를 로드할 때 데이터를 기다릴 필요 없이 즉시 렌더링할 수 있습니다.
- **보안 강화**: 민감한 사용자 정보 페칭 로직이 서버에서 실행되므로, 클라이언트 측에 노출될 위험이 줄어듭니다.
- **상태 관리 간소화**: React Context API를 통해 서버에서 가져온 사용자 정보를 애플리케이션 전반의 클라이언트 컴포넌트에서 쉽게 접근하고 사용할 수 있게 되었습니다. MobX와 같은 외부 라이브러리 의존성을 줄이고 Next.js의 권장 패턴에 더 가깝게 전역 상태를 관리합니다.

아래는 기존 클라이언트 사이드 기반의 사용자 정보 로딩 방식과, Next.js App Router에서 SSR 기반으로 변경된 방식의 비교 코드입니다.

```javascript
// Before: pages/_app.js (사용자 정보 클라이언트 사이드 로딩 및 MobX 스토어 사용)
import React from "react";
import App from "next/app";
import httpClient from "axios"; // HTTP 클라이언트
import { Provider, observer } from "mobx-react";
import stores from "stores"; // MobX store 임포트

class MyApp extends App {
  componentDidMount() {
    // 클라이언트 사이드에서만 실행
    async function checkAuth() {
      const cookies = document.cookie;
      if (cookies.includes("auth_token")) {
        // 인증 쿠키 확인
        try {
          const response = await httpClient.get(`/api/auth/user`); // 클라이언트에서 API 호출
          const { name, id, roles, isActive } = response.data;

          // ... 권한 체크 및 리다이렉트 로직 (클라이언트 사이드) ...
          let { userStore } = stores;
          userStore.setUserInfo(name, id, roles[0]); // MobX store에 저장
          if (router.pathname === "/") router.push("/dashboard");
        } catch (e) {
          window.location.href = `${AUTH_URL}?callbackUrl=${window.location.href}`;
        }
      } else {
        window.location.href = `${AUTH_URL}?callbackUrl=${window.location.href}`;
      }
    }
    checkAuth();
  }

  render() {
    const { Component, pageProps } = this.props;
    return (
      <Provider {...stores}>
        // MobX Provider
        <Layout>
          <Component {...pageProps} />
        </Layout>
      </Provider>
    );
  }
}
export default observer(MyApp);
```

이전 방식에서는 `pages/_app.js`의 `componentDidMount` 훅에서 `checkAuth` 함수를 비동기적으로 호출하여 사용자 인증 상태를 확인하고, `httpClient`를 통해 API 엔드포인트에 사용자 정보를 요청했습니다. 이 정보는 `stores`라는 MobX 스토어에 저장되어 전역적으로 사용되었죠. 만약 인증에 실패하거나 권한이 없는 경우, `window.location.href`를 사용하여 로그인 서비스로 리다이렉트하는 방식으로 처리되었습니다. 이 과정은 모두 클라이언트 사이드에서 발생했기 때문에, 초기 페이지 로딩 시 빈 화면이 보이거나 깜빡이는 현상이 발생할 수 있었습니다.

```javascript
// After: providers/UserSessionProvider.js (Client Component)
"use client"; // 이 컴포넌트는 클라이언트 컴포넌트임을 명시
import { createContext, useContext, useEffect, useState } from "react";

const UserContext = createContext(); // Context 객체 생성

export default function UserSessionProvider({
  userName,
  userId,
  userRoles,
  error,
  children,
}) {
  useEffect(() => {
    if (error) {
      alert(error); // 에러 발생 시 사용자에게 알림
      window.location.href = `${AUTH_URL}?callbackUrl=${window.location.href}`; // 로그인 페이지로 리다이렉트
      return;
    }
  }, [error]); // error prop이 변경될 때마다 실행

  const [userState] = useState({
    userName,
    userId,
    userRoles,
  });

  return (
    <UserContext.Provider value={userState}>{children}</UserContext.Provider>
  );
}

export function useUser() {
  // 사용자 정보를 가져오는 커스텀 훅
  return useContext(UserContext);
}
```

`UserSessionProvider`는 `"use client"` 지시어가 있는 클라이언트 컴포넌트입니다. `app/layout.js` 서버 컴포넌트로부터 `userName`, `userId`, `userRoles`, `error` 등의 props를 받아 `useState`를 통해 `userState`를 초기화합니다. `useEffect` 훅은 `error` prop의 변화를 감지하여, 만약 에러가 발생했다면 사용자에게 경고 메시지를 표시하고 `AUTH_URL`로 리다이렉트하여 로그인 흐름을 시작하도록 합니다. `UserContext.Provider`를 통해 `userState`를 하위 컴포넌트들에게 제공하며, `useUser` 커스텀 훅을 통해 어떤 클라이언트 컴포넌트에서든 쉽게 사용자 정보에 접근할 수 있게 합니다. 이로써 사용자 인증 및 상태 관리가 Next.js의 서버 컴포넌트와 React Context API의 조합으로 더욱 견고하고 효율적으로 이루어지게 되었습니다.

---

## 미들웨어와 라우팅 최적화

Next.js 15 App Router로 마이그레이션하면서 `middleware.ts`를 도입하여 요청 전처리를 중앙 집중화했습니다. 기존 Express 서버에서 처리하던 전역적인 요청 로직(인증, 리다이렉션 등)을 Next.js 미들웨어로 이관한 것입니다.

**Next.js 미들웨어**는 요청이 완료되기 전에 코드를 실행하여, 들어오는 요청에 따라 응답을 수정(재작성, 리다이렉션, 헤더 추가 등)할 수 있는 강력한 기능을 제공합니다. `middleware.ts` 파일은 캐시된 콘텐츠 및 라우트 매칭 전에 실행되므로, 애플리케이션의 모든 요청에 대한 전역적인 처리에 매우 적합합니다.

이 미들웨어를 활용하여:

- **인증 쿠키 확인**: 모든 인바운드 요청에 대해 인증 쿠키(`auth_token`)의 존재 여부를 확인합니다.
- **로그인 리다이렉트**: 인증 쿠키가 없으면 `AUTH_URL`로 리다이렉트하여 로그인 절차를 유도합니다.
- **루트 경로 처리**: 루트 경로(`/`)로의 직접적인 접근은 기본 대시보드 페이지인 `/dashboard`로 리다이렉트하여 사용자의 초기 진입점을 명확히 합니다.
- **상태 확인 엔드포인트**: `/health`와 같은 헬스 체크 경로 요청에 대해서는 즉시 응답을 반환하여 서버 상태를 확인할 수 있도록 합니다.

이 외에도 `next/router` 훅에서 `next/navigation` (`useRouter`, `useSearchParams`, `usePathname`) 훅으로 전환하여 클라이언트 라우팅 로직을 App Router에 최적화했습니다. 또한, `dynamic import` 대신 정적 `import`를 적극적으로 사용하여 **트리 쉐이킹(Tree Shaking)** 효과를 극대화하고 최종 번들 사이즈를 줄여 페이지 로딩 성능을 추가적으로 개선했습니다. 트리 쉐이킹은 사용되지 않는 코드를 번들에서 제거하여 자바스크립트 번들 크기를 최적화하는 기법으로, ES 모듈의 정적 분석 특성을 활용합니다.

```typescript
// middleware.ts (Next.js 미들웨어)
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const hasAuthToken = request.cookies.has("auth_token"); // 인증 쿠키 확인
  const authUrl = new URL(process.env.AUTH_URL || "/login", request.url); // 로그인 페이지 URL

  // 1. 인증되지 않은 사용자를 로그인 페이지로 리다이렉트
  if (!hasAuthToken && !request.nextUrl.pathname.startsWith("/login")) {
    // 로그인 페이지가 아닌데 인증 쿠키가 없으면
    // 콜백 URL을 포함하여 로그인 서비스로 리다이렉트
    const redirectUrl = `${authUrl.href}?callbackUrl=${encodeURIComponent(
      request.url
    )}`;
    return NextResponse.redirect(redirectUrl);
  }

  // 2. 루트 경로('/')로 접근 시 '/dashboard' 페이지로 리다이렉트
  if (request.nextUrl.pathname === "/") {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  // 3. /health 경로 요청 처리 (서버 헬스 체크)
  if (request.nextUrl.pathname === "/health") {
    return NextResponse.json({ status: "ok" });
  }

  // 기본적으로 다음 요청 처리로 넘어감
  return NextResponse.next();
}

// 미들웨어가 실행될 경로를 지정 (선택 사항)
export const config = {
  matcher: [
    /*
     * 모든 인바운드 요청에 미들웨어 적용:
     * - /api/로 시작하는 모든 경로
     * - /_next/static/ 또는 /_next/image/로 시작하지 않는 모든 경로 (Next.js 내부 파일 제외)
     * - /favicon.ico와 같은 파일 제외
     * - 루트 경로 및 특정 페이지 경로
     */
    "/",
    "/api/:path*",
    "/dashboard/:path*",
    "/users/:path*",
    "/data/:path*",
    "/health",
  ],
};
```

위 코드는 Next.js 미들웨어인 `middleware.ts`의 핵심 로직입니다. `NextRequest` 객체를 통해 요청 정보를 분석하고 `NextResponse`를 통해 응답을 제어합니다. 가장 먼저 `auth_token`의 존재 여부를 확인하여, 인증되지 않은 사용자라면 `AUTH_URL`로 리다이렉트합니다. 이어서 루트 경로(`/`)로의 접근을 `/dashboard` 페이지로 리다이렉트하고, `/health` 경로에 대한 헬스 체크 응답을 처리합니다. `config.matcher`는 이 미들웨어가 적용될 경로를 명시하여 불필요한 경로에서는 미들웨어가 실행되지 않도록 최적화합니다. 이처럼 미들웨어를 통해 전역적인 요청 처리 로직을 중앙에서 관리함으로써 코드의 일관성과 유지보수성을 높였습니다.

---

## 환경 변수 관리 간소화

Next.js는 `.env` 파일을 통한 환경 변수 관리를 내장하고 있습니다. 기존에는 `dotenv.config()`를 직접 호출하거나 `package.json` 스크립트에서 환경 변수를 명시적으로 설정하는 방식이었으나, 마이그레이션 이후에는 Next.js가 `.env`, `.env.local`, `.env.development`, `.env.production` 파일들을 자동으로 로드하도록 변경하여 환경 변수 관리를 훨씬 간소화했습니다.

특히, 클라이언트 사이드 코드에서 접근해야 하는 환경 변수에는 반드시 `NEXT_PUBLIC_` 접두사를 붙여야만 번들링 과정에서 클라이언트에 노출됩니다. 이를 통해 개발, 테스트, 프로덕션 환경에 따라 유연하게 설정을 관리할 수 있게 되었으며, 서버 전용 환경 변수가 클라이언트에 노출되는 보안 위험도 방지할 수 있습니다. `next.config.ts`, `Dockerfile`, `package.json` 파일에서 이러한 변경 사항을 반영하여 환경 변수 설정 및 관리가 더욱 효율적으로 이루어지도록 했습니다.

---

## 마이그레이션 결과 및 얻은 교훈

이번 Next.js 15 App Router 마이그레이션을 통해 다음과 같은 유의미한 개선을 이루었습니다.

- **성능 향상**: 서버 컴포넌트를 활용한 SSR과 최적화된 API 계층을 통해 초기 로딩 속도가 빨라졌습니다. 사용자 인증 정보도 서버에서 미리 가져오므로 클라이언트에서 대기하는 시간이 줄었습니다.
- **유지보수성 개선**: Express 서버를 제거하고 Next.js App Router 기반의 단일 프레임워크 스택으로 통합되어 코드 베이스가 간결해지고 개발 복잡성이 감소했습니다. 공통 API 유틸리티와 미들웨어 도입으로 로직의 재사용성과 일관성이 향상되었습니다.
- **개발 경험 증진**: TypeScript 적용과 App Router의 명확한 구조화 덕분에 개발자들이 코드의 의도를 파악하고 새로운 기능을 추가하기가 더 쉬워졌습니다.

물론, 마이그레이션 과정에서 여러 도전 과제도 있었습니다.

- **클라이언트/서버 컴포넌트 경계 이해**: 기존의 클라이언트 중심 React 개발 방식에서 서버 컴포넌트와 클라이언트 컴포넌트의 명확한 경계를 이해하고 적절히 활용하는 데 시간이 필요했습니다. 특히, 데이터 직렬화 제약 사항과 `useState`, `useEffect` 등의 훅 사용 가능 여부를 명확히 구분하는 것이 중요했습니다.
- **데이터 페칭 및 에러 핸들링 전략**: 서버 컴포넌트, Route Handler, 클라이언트 컴포넌트 각 계층에서 발생하는 에러를 어떻게 통합적으로 처리하고 사용자에게 피드백할 것인지에 대한 전략 수립이 중요했습니다.
- **점진적 마이그레이션의 어려움**: 레거시 코드가 많았기 때문에 한 번에 모든 것을 전환하기보다, 주요 페이지부터 App Router로 전환하고 기존 Page Router와 App Router를 한동안 공존시키면서 점진적으로 마이그레이션하는 전략이 필요했습니다. `next/router`와 `next/navigation`을 혼용하지 않도록 주의해야 했습니다.

이번 마이그레이션은 단순한 기술 스택 변경을 넘어, 애플리케이션의 근본적인 구조를 현대화하고 미래 지향적인 개발 환경을 구축하는 중요한 전환점이었습니다. 앞으로도 Next.js App Router의 잠재력을 최대한 활용하여 더욱 안정적이고 효율적인 서비스를 제공할 수 있도록 노력할 것입니다.

---

## 참고 자료

- [Next.js 공식 문서 - App Router](https://nextjs.org/docs/app)
- [Next.js 공식 문서 - Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)
- [Next.js 공식 문서 - Environment Variables](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)

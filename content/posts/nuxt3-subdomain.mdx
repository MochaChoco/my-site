---
title: "Nuxt 3 프로젝트에서 서브도메인 처리하기"
description: "Nuxt 3의 커스텀 라우팅(`app/router.options.ts`)을 이용해 서브도메인에 따라 PC/모바일 페이지를 분기하는 방법과 구현 포인트를 정리합니다."
date: "2023-10-16"
tags: ["nuxt3", "router", "subdomain", "frontend"]
slug: "nuxt3-subdomain"
coverImage: "/images/posts/nuxt3-subdomain/cover.png"
---

![커버 이미지](/images/posts/nuxt3-subdomain/cover.png)

기존에 Nuxt 3로 만들어진 PC용 사이트에 서브도메인을 적용하여, 서브도메인에 따라 PC/모바일 화면이 구분되도록 만들어야 했습니다. 이번 포스트에서는 Nuxt 3 프로젝트에서 서브도메인에 따라 페이지를 분기하는 방법을 정리해보겠습니다.

## 서브도메인이란?

서브도메인은 웹사이트의 영역을 구분하기 위해 도메인 이름 앞에 추가되는 접두사를 의미합니다. 서브도메인을 사용하면 상점, 블로그, 게시판처럼 자체적인 계층 구조가 필요한 영역을 분리하여 관리하기가 쉬워집니다.

예를 들어 네이버 포털 사이트는 여러 서비스를 아래처럼 서브도메인으로 구분하고 있습니다.

1.  네이버 홈: https://www.naver.com
2.  네이버 카페 : https://section.cafe.naver.com
3.  네이버 블로그 : https://section.blog.naver.com
4.  네이버 쇼핑 : https://shopping.naver.com

## 적용방법

Nuxt 3는 기본적으로 파일 기반 라우팅을 사용합니다. 별도 설정이 없다면 `pages` 폴더 내부의 경로를 기반으로 route 주소가 생성됩니다. 예를 들어 `pages/test-123/index.vue` 파일을 만들면 경로는 `http://localhost:3000/test-123`이 됩니다. 이런 방식은 React 기반의 Next.js와도 유사합니다.

따라서 서브도메인에 따라 라우팅을 분기하려면 라우팅 설정을 커스텀해야 합니다. [Nuxt 3 공식 문서](https://nuxt.com/docs/guide/going-further/custom-routing#adding-custom-routes)에서도 `app/router.options.ts` 파일을 만들어 라우팅을 커스텀하는 방식을 안내하고 있습니다.

우선 저는 `pages` 폴더를 아래처럼 구분했습니다.

<img
  src="/images/posts/nuxt3-subdomain/image1.png"
  style={{ maxWidth: "280px" }}
  alt="파일 구조"
/>

`pages` 폴더 내부에 `pc`, `mobile` 폴더를 나누고 각각 사용할 페이지 파일들을 구성합니다. 그리고 프로젝트 루트에 `app` 폴더를 만들고, 그 안에 `router.options.ts` 파일을 생성해 아래처럼 작성합니다.

```javascript
import type { RouterConfig } from "@nuxt/schema";

export default <RouterConfig>{
  routes: (_routes) => {
    const { ssrContext } = useNuxtApp();
    const pcSubDomain = "localhost";
    const mobileSubDomain = "m";
    let routesDirectory: any = null;

    // server-side에서 url로 subDomain 체크
    if (process.server && ssrContext && ssrContext.event.node.req) {
      const req = ssrContext.event.node.req;
      const subDomain = req.headers.host?.split(".")[0];

      if (subDomain === "www" || subDomain === pcSubDomain) {
        routesDirectory = "pc";
      } else if (subDomain === mobileSubDomain) {
        routesDirectory = "mobile";
      }
    }

    // client-side에서 url로 subDomain 체크
    if (process.client && window.location.hostname) {
      const subDomain = window.location.hostname.split(".")[0];

      if (subDomain === "www" || subDomain === pcSubDomain) {
        routesDirectory = "pc";
      } else if (subDomain === mobileSubDomain) {
        routesDirectory = "mobile";
      }
    }

    // route의 경로와 pages 폴더의 경로를 비교
    function checkIsUnderDirectory(route: any, directory: "pc" | "mobile") {
      const path = route.path;
      return path === "/" + directory || path.startsWith("/" + directory + "/");
    }

    let newRoutes = [..._routes];

    if (routesDirectory) {
      newRoutes = _routes
        .filter((route: any) => {
          // routesDirectory가 pc면 pc 경로만, mobile이면 mobile 경로만 가져옴
          return checkIsUnderDirectory(route, routesDirectory);
        })
        .map((route: any) => {
          // 접근가능한 route 경로 재설정
          return {
            ...route,
            path: route.path.substr(routesDirectory.length + 1) || "/",
            name: route.name || "index",
          };
        });
      return newRoutes;
    }
  },
};
```

위 코드는 로컬 환경에서 테스트한 기준이며, PC 버전은 `http://localhost:3000`, 모바일 버전은 `http://m.localhost:3000`일 때 각각 화면이 출력되도록 작성했습니다.

코드를 나눠서 설명하면 다음과 같습니다.

```javascript
const { ssrContext } = useNuxtApp();
const pcSubDomain = "localhost";
const mobileSubDomain = "m";
let routesDirectory: any = null;

// server-side에서 url로 subDomain 체크
if (process.server && ssrContext && ssrContext.event.node.req) {
  const req = ssrContext.event.node.req;
  const subDomain = req.headers.host?.split(".")[0];

  if (subDomain === "www" || subDomain === pcSubDomain) {
    routesDirectory = "pc";
  } else if (subDomain === mobileSubDomain) {
    routesDirectory = "mobile";
  }
}

// client-side에서 url로 subDomain 체크
if (process.client && window.location.hostname) {
  const subDomain = window.location.hostname.split(".")[0];

  if (subDomain === "www" || subDomain === pcSubDomain) {
    routesDirectory = "pc";
  } else if (subDomain === mobileSubDomain) {
    routesDirectory = "mobile";
  }
}
```

먼저 `split(".")`으로 host를 나누면 문자열 배열이 나오는데, 첫 번째 값이 `m`인지 여부에 따라 `routesDirectory`에 `pc` 또는 `mobile` 값을 할당합니다. 이 과정은 올바른 경로만 허용하기 위한 것으로, 서브도메인에 `m`이나 `localhost` 외의 값이 들어왔을 때 404를 반환하도록 하기 위함입니다.

위 코드에서는 server-side, client-side를 모두 체크하고 있습니다. 만약 `nuxt.config.ts`에서 `ssr: false`로 CSR 사이트를 구성하신다면, server-side 체크 로직은 제거(또는 주석 처리)하셔도 무방합니다.

```javascript
// route의 경로와 pages 폴더의 경로를 비교
function checkIsUnderDirectory(route: any, directory: "pc" | "mobile") {
  const path = route.path;
  return path === "/" + directory || path.startsWith("/" + directory + "/");
}

let newRoutes = [..._routes];

if (routesDirectory) {
  newRoutes = _routes
    .filter((route: any) => {
    // routesDirectory가 pc면 pc 경로만, mobile이면 mobile 경로만 가져옴
    return checkIsUnderDirectory(route, routesDirectory);
  })
    .map((route: any) => {
    // 접근가능한 route 경로 재설정
    return {
      ...route,
      path: route.path.substr(routesDirectory.length + 1) || "/",
      name: route.name || "index",
    };
  });
  return newRoutes;
}
```

그 다음으로는 Nuxt가 파일 라우팅 기반으로 자동 생성한 route 객체를 수정해야 합니다. route 객체는 `_routes` 배열에 담겨 있고, `filter`로 각 route마다 `checkIsUnderDirectory`를 호출해 `pages` 폴더 구조와 일치하는 것만 걸러냅니다.

따라서 `routesDirectory` 값이 `pc`라면 `pages/pc` 하위 항목들만 가져오고, `mobile`이라면 `pages/mobile` 하위 항목들만 가져오게 됩니다.

<img
  src="/images/posts/nuxt3-subdomain/image2.png"
  style={{ maxWidth: "320px" }}
  alt="도메인"
/>

이렇게 필터링된 `newRoutes` 배열을 다시 `map`으로 순회하면서 route의 `path` 값을 수정하면, Nuxt에서는 해당 경로만 접근 가능하도록 처리됩니다.

> #### ※ API 사용 시 참고
>
> API 호출 시 CORS 오류가 발생한다면, 서버의 origin 예외 처리 항목에 `http://m.localhost.com`을 추가해주셔야 합니다.

## 실행 결과

하위 경로는 유지한 채 서브도메인에 맞는 페이지가 노출되고, 서브도메인에 잘못된 값을 넣으면 에러 페이지로 이동하는 것을 확인할 수 있습니다.

<img
  src="/images/posts/nuxt3-subdomain/image3.png"
  style={{ maxWidth: "320px" }}
  alt="실행 결과"
/>

## 샘플 코드

[git 저장소 이동 (https://github.com/MochaChoco/sub-domain-test)](https://github.com/MochaChoco/sub-domain-test)

## 참고 자료

- [Adding custom routes - Nuxt.js document](https://nuxt.com/docs/guide/going-further/custom-routing#adding-custom-routes)
- [How to use subdomain in Nuxt 3 - stackoverflow](https://stackoverflow.com/questions/76207075/how-to-use-subdomain-in-nuxt-3)

---
title: "OAuth 기반 소셜 로그인 구현하기"
description: "Vue 3와 Pinia를 활용하여 복잡한 소셜 로그인 플로우를 효과적으로 관리하고, 다양한 계정 충돌 시나리오를 처리하는 방법을 공유합니다."
date: "2025-01-07"
tags: ["vue", "auth"]
slug: "social-auth-implementation"
coverImage: "/images/posts/social-auth-implementation/cover.png"
---

<img
  src="/my-site/images/posts/social-auth-implementation/cover.png"
  style={{ width: "320px" }}
  alt="커버 이미지"
/>

안녕하세요! 이번 포스팅에서는 복잡한 사용자 로그인 및 회원가입, 특히 소셜 로그인 통합 과정에서 겪었던 시행착오와 개선점을 공유하고자 합니다. 프로젝트의 프론트엔드 개발을 진행하며, 이메일 기반 회원가입과 구글, 네이버와 같은 소셜 계정을 통한 회원가입/로그인 흐름을 통합하는 과정은 여러 가지 도전 과제를 안겨주었습니다.

처음에는 각기 다른 인증 방식과 다단계 폼 데이터를 관리하는 데 어려움을 겪었습니다. 특히 소셜 로그인 시 신규 가입, 기존 계정 충돌, 계정 연동 등 다양한 시나리오를 처리해야 했기에, 코드의 복잡성이 증가하고 유지보수도 쉽지 않았습니다. 이러한 문제들을 해결하기 위해 저희 팀은 Vue 3의 Pinia 스토어를 활용한 중앙 집중식 상태 관리와 `Composition API`를 이용한 로직 분기에 집중했습니다. 이 글을 통해 그 과정과 결과를 자세히 소개하려 합니다.

## 복잡한 인증 플로우, 어떻게 관리했나? (개념 설명)

회원가입/로그인 시스템은 사용자 경험과 보안이라는 두 가지 중요한 축을 동시에 만족시켜야 합니다. 특히 이메일과 소셜 로그인이라는 두 가지 큰 줄기를 통합할 때는 더 섬세한 접근이 필요하죠. 저희가 이 과정에서 활용한 주요 기술 개념들과 그 흐름에 대해 먼저 설명드리겠습니다.

### OAuth 2.0: 간편하고 안전한 권한 위임

소셜 로그인 구현의 핵심은 바로 **OAuth 2.0** 프로토콜입니다. OAuth 2.0은 사용자가 자신의 비밀번호를 웹 애플리케이션에 직접 제공하지 않고도, 구글이나 네이버와 같은 외부 서비스(리소스 소유자)의 리소스에 우리 애플리케이션(클라이언트)이 접근할 수 있도록 권한을 위임하는 개방형 표준입니다. 이는 보안성을 높이면서 사용자에게는 번거로운 회원가입 절차 없이 간편하게 로그인할 수 있는 편의성을 제공합니다.

저희 시스템에서는 사용자가 로그인 페이지에서 소셜 로그인 버튼을 클릭하는 것으로 OAuth 인증 흐름이 시작됩니다. 애플리케이션은 OAuth 제공자의 SDK를 초기화하고, 사용자 인증을 위해 제공자 페이지로 리다이렉션하거나 팝업을 띄웁니다. 사용자가 외부 서비스에서 인증을 완료하면, 제공자는 미리 등록된 콜백 URL로 사용자를 다시 리다이렉션하며 `access_token` 등의 정보를 전달하게 됩니다.

OAuth 2.0에는 여러 인증 흐름(Grant Type)이 있는데, 저희는 구글과 네이버의 특성에 맞춰 **Implicit Flow** (또는 이와 유사한 형태)와 **Authorization Code Flow**를 각각 사용했습니다.

- **Implicit Flow**: 구글 로그인의 경우, 주로 클라이언트 측 웹 애플리케이션에서 `access_token`을 직접 받는 방식에 가깝습니다. 구현이 비교적 간단하지만, 토큰이 URL 해시 프래그먼트를 통해 직접 노출될 수 있어 보안에 취약할 수 있다는 점을 인지해야 합니다. 최근에는 `Authorization Code Flow with PKCE`가 더 권장됩니다.
- **Authorization Code Flow**: 네이버 로그인에 사용된 방식입니다. 이 방식은 클라이언트가 사용자로부터 권한을 위임받기 위해 먼저 `Authorization Code`를 발급받고, 이 코드를 백엔드 서버에서 `Access Token`으로 교환하는 과정을 거칩니다. `Authorization Code`가 직접 토큰이 아니므로 URL 노출 위험이 적고, 서버 측 웹 애플리케이션에 더 적합하여 보안성이 높습니다. 이때 `state` 파라미터를 사용하여 CSRF 공격을 방어하는 것이 중요합니다.

저희 `SocialAuthHandler composable`에서는 이처럼 다른 OAuth 흐름을 추상화하여, 프론트엔드에서는 `login(provider, token)`과 같이 통일된 방식으로 처리할 수 있도록 구현했습니다.

### Pinia와 Vue 3 Composition API: 상태 관리와 로직 재사용의 핵심

복잡한 다단계 회원가입 폼과 여러 소셜 로그인 시나리오를 효과적으로 관리하기 위해 Vue 3의 **Pinia**와 **Composition API**를 적극적으로 활용했습니다.

- **Pinia**: Vue 3를 위한 경량 상태 관리 라이브러리로, Vuex 5의 비전을 계승했습니다. Pinia는 중앙 집중식 상태 관리를 통해 애플리케이션 전체에서 공유되는 상태를 예측 가능하고 효율적으로 관리할 수 있게 돕습니다. 특히 `RegistrationStore`를 통해 회원가입의 `step` 정보와 각 단계의 폼 데이터를 한 곳에서 관리함으로써, `props drilling`과 같은 문제 없이 컴포넌트 간의 결합도를 낮추고 데이터 흐름을 명확히 할 수 있었습니다. `storeToRefs`를 사용하면 스토어의 상태를 컴포넌트에서 반응적으로 구조 분해 할당하여 사용할 수 있어 개발 편의성이 더욱 높아집니다.
- **Vue 3 Composition API (Composables)**: Composition API는 논리적 관심사에 따라 코드를 구성하고 재사용 가능한 로직을 추출하기 위한 강력한 기능 세트입니다. 저희는 `composables/social.js` 파일에 `useSocialLogin`과 같은 `composable` 함수를 정의하여 소셜 로그인/회원가입 분기 로직을 캡슐화했습니다. 이렇게 함으로써 복잡한 비즈니스 로직을 컴포넌트로부터 분리하고, 여러 컴포넌트에서 동일한 로직을 재사용하며 유지보수성을 향상시킬 수 있었습니다.

### Debounce: 불필요한 API 호출 줄이기

이메일이나 닉네임 중복 확인과 같은 실시간 유효성 검증 시, 사용자가 글자를 입력할 때마다 즉시 API를 호출하면 서버에 불필요한 부하를 줄 수 있습니다. 이를 해결하기 위해 **Debounce** 기법을 적용했습니다. Debounce는 짧은 시간 간격으로 발생하는 여러 이벤트를 그룹화하여 특정 함수가 한 번만 실행되도록 지연시키는 최적화 기법입니다. 예를 들어, 사용자가 타이핑을 멈춘 후 500ms가 지나야 중복 확인 API를 호출하도록 설정하여, 서버 리소스 사용을 효율화하고 사용자 경험을 개선했습니다.

이러한 기술 스택을 바탕으로, 저희는 사용자가 소셜 계정으로 로그인/회원가입을 시도할 때 다음과 같은 주요 흐름을 통해 처리합니다:

1.  **OAuth 인증 시작 및 콜백 처리**: 사용자가 소셜 로그인 버튼을 클릭하면, 해당 소셜 프로바이더의 OAuth 인증 흐름을 시작합니다. 인증 성공 후, 등록된 콜백 URL로 리다이렉션되면서 토큰 정보가 전달됩니다.
2.  **로그인 시도**: `useSocialLogin().performLogin()` 함수를 통해 해당 소셜 계정으로 기존 사용자가 있는지 확인합니다.
3.  **로그인 성공 시**: 기존 사용자의 경우 즉시 로그인 처리되고, `LoginRedirectHandler`를 통해 사용자를 원래 목표했던 페이지로 이동시킵니다.
4.  **로그인 실패 시 (신규 사용자 또는 계정 충돌)**: `handleSocialLoginFailure()` 함수가 호출되어 소셜 프로바이더로부터 사용자 정보(주로 이메일)를 가져옵니다. 이 정보를 기반으로 백엔드 API (`checkSocialUserStatus`)를 호출하여 계정 존재 여부 및 충돌 시나리오를 상세하게 분석합니다.
5.  **시나리오별 분기 처리**: 기존 이메일 계정 존재 여부, 소셜 계정 연동 여부, 이메일 인증 여부 등을 확인하여 적절한 경고 메시지를 표시하거나, 새로운 회원가입 플로우를 시작하도록 유도합니다.
6.  **신규 소셜 회원가입**: 신규 가입자인 경우, `RegistrationStore`에 소셜 이메일, 프로바이더, 토큰을 저장하고 회원가입 뷰로 이동시킵니다. 이때 이메일과 같은 정보는 자동으로 채워지며, 비밀번호 입력 필드는 숨겨집니다.
7.  **회원가입 최종 제출**: 모든 정보를 입력한 후, `RegistrationStore.submitRegistration()` 함수를 통해 소셜 프로바이더 정보와 토큰을 포함한 가입 정보를 백엔드 API로 전송합니다.
8.  **회원가입 완료 및 자동 로그인**: 성공적인 응답을 받으면 자동 로그인 처리되고, 사용자는 최종 페이지로 리다이렉트됩니다.

이러한 흐름 속에서 Pinia와 Composables는 복잡한 로직을 체계적으로 관리하고, 코드의 가독성과 유지보수성을 극대화하는 데 결정적인 역할을 했습니다.

## 구현 포인트: Pinia로 다단계 폼 상태 관리 개선

저희가 마주했던 첫 번째 큰 도전은 다단계 회원가입 폼의 상태를 효율적으로 관리하는 것이었습니다. 이전에는 `SignupView.vue` 컴포넌트가 `stepIdx`와 `formData` 같은 로컬 상태를 직접 관리하고, `moveToNextStep` 같은 함수를 `props`로 자식 컴포넌트에 전달하는 방식이었습니다. 이는 `props drilling`을 유발하고 컴포넌트 간의 의존성을 높여 코드 변경 시 예상치 못한 부작용을 초래하기 쉬웠습니다.

**변경 전 (`SignupView.vue` 및 자식 컴포넌트)**

```vue
<!-- SignupView.vue (일부) -->
<template>
  <div class="sign-up-page">
    <EmailVerificationForm
      v-if="stepIndex === 1"
      :step="stepIndex"
      :email="formData.email"
      :registrationType="currentRegistrationType"
      :moveToNextStep="goToNextStep"
    />
    <AuthCodeVerificationForm
      v-else-if="stepIndex === 2"
      :step="stepIndex"
      :moveToNextStep="goToNextStep"
    />
    <NicknameInputForm
      v-else-if="stepIndex === 3"
      :step="stepIndex"
      :moveToNextStep="goToNextStep"
    />
    <RegistrationCompleteView v-else-if="stepIndex === 4" />
  </div>
</template>

<script setup>
import { ref, computed, watch, onBeforeMount } from "vue";
import { useRoute } from "vue-router";
// ... import components
import { useRegistrationStore } from "@/stores/registration";

const route = useRoute();
const registrationStore = useRegistrationStore();

const stepIndex = ref(1); // 로컬 상태로 단계 관리
const formData = ref({
  // 로컬 상태로 폼 데이터 관리
  email: "",
  password: "",
  terms: [],
  birthDay: 0,
  nickname: "",
});

const currentRegistrationType = computed(() => {
  /* ... */
});

function goToNextStep(data) {
  // 자식 컴포넌트로부터 데이터를 받아 로컬 상태 업데이트
  stepIndex.value++;
  formData.value = { ...formData.value, ...data };
}

onBeforeMount(() => {
  formData.value.email = registrationStore.getEmail(); // 초기 이메일만 스토어에서 가져옴
});

watch(
  () => formData.value,
  () => {
    console.log("formData", formData.value);
  }
);
</script>

<!-- EmailVerificationForm.vue (자식 컴포넌트 예시 일부) -->
<script setup>
import { useRegistrationStore } from "@/stores/registration";
// ... imports

const props = defineProps({
  step: { type: Number, required: true },
  goToNextStep: { type: Function, required: true }, // props로 함수 받음
  email: { default: "", required: false },
  registrationType: { default: "default", required: false },
});

const registrationStore = useRegistrationStore();

// ... form field definitions ...

function handleMoveToNextStep() {
  // props로 받은 함수를 호출하며 로컬 폼 데이터 전달
  props.goToNextStep({
    email: emailFields.value[0].modelValue,
    password: passwordFields.value[0].modelValue,
    terms: selectedTerms.value,
  });

  // 일부 데이터는 스토어에 저장하지만, 전체 흐름은 여전히 props와 emit에 의존
  registrationStore.setEmail(emailFields.value[0].modelValue);
  registrationStore.setPassword(passwordFields.value[0].modelValue);
  registrationStore.agreeMarketing(
    selectedTerms.value.includes(termsOptions[2])
  );
}
</script>
```

이전 코드에서는 `SignupView`가 회원가입 단계(`stepIndex`)와 전체 폼 데이터(`formData`)를 모두 관리하고 있었습니다. 각 자식 컴포넌트 (`EmailVerificationForm`, `AuthCodeVerificationForm` 등)는 `goToNextStep` 함수를 `props`로 받아 데이터를 전달하고 다음 단계로 이동하는 로직을 수행했습니다. 이 방식은 컴포넌트 간의 직접적인 의존성을 만들고, `SignupView`가 너무 많은 책임을 지게 만들었습니다. 즉, 데이터의 흐름을 파악하기 어렵고, 특정 단계의 로직이 변경될 경우 관련된 모든 컴포넌트를 수정해야 하는 불편함이 있었습니다.

**변경 후 (`SignupView.vue` 및 자식 컴포넌트)**

```vue
<!-- SignupView.vue (일부) -->
<template>
  <div class="sign-up-page">
    <EmailVerificationForm
      v-if="currentStep === 1"
      :step="currentStep"
      :email="registrationStore.getEmail()"
      :registrationType="currentRegistrationType"
    />
    <AuthCodeVerificationForm
      v-else-if="currentStep === 2"
      :step="currentStep"
    />
    <NicknameInputForm v-else-if="currentStep === 3" :step="currentStep" />
    <RegistrationCompleteView v-else-if="currentStep === 4" />
  </div>
</template>

<script setup>
import { computed, onBeforeUnmount } from "vue";
import { useRoute } from "vue-router";
// ... import components
import { useRegistrationStore } from "@/stores/registration";
import { storeToRefs } from "pinia"; // Pinia 스토어의 반응형 속성을 직접 사용

const route = useRoute();
const registrationStore = useRegistrationStore();

const { step: currentStep } = storeToRefs(registrationStore); // Pinia 스토어의 step 상태를 직접 가져와 사용

const currentRegistrationType = computed(() => {
  /* ... */
});

// goToNextStep 함수가 필요 없어짐. 각 컴포넌트가 직접 store.setStep() 호출
// 로컬 formData 상태도 필요 없어짐. 모든 폼 데이터는 스토어에서 관리
onBeforeUnmount(() => {
  if (registrationStore.getStep() === 4) {
    // 회원가입 완료 후 스토어 초기화
    registrationStore.resetState();
  }
});
</script>

<!-- EmailVerificationForm.vue (자식 컴포넌트 예시 일부) -->
<script setup>
import { useRegistrationStore } from "@/stores/registration";
// ... imports

const props = defineProps({
  step: { type: Number, required: true },
  email: { default: "", required: false },
  registrationType: { default: "default", required: false },
});

const registrationStore = useRegistrationStore();

// ... form field definitions ...

function handleMoveToNextStep() {
  // Pinia 스토어에 직접 폼 데이터 저장 및 step 업데이트
  registrationStore.setEmail(emailFields.value[0].modelValue);
  registrationStore.setPassword(passwordFields.value[0].modelValue);
  registrationStore.agreeMarketing(
    selectedTerms.value.includes(termsOptions[2])
  );
  registrationStore.setStep(2); // 다음 단계로 이동
}
</script>
```

Pinia를 도입한 후, `SignupView`는 단순히 `registrationStore`의 `step` 상태에 따라 적절한 단계 컴포넌트를 렌더링하는 역할만 수행하도록 변경되었습니다. `storeToRefs`를 통해 `currentStep`을 직접 참조하면서, `SignupView`의 로컬 `stepIndex` 상태는 더 이상 필요 없게 되었죠. 가장 큰 변화는 각 단계 컴포넌트가 `goToNextStep` `props` 없이 직접 `registrationStore.setStep()`을 호출하여 다음 단계로 이동하고, 입력된 폼 데이터를 `registrationStore`에 즉시 저장한다는 점입니다. 이로써 `SignupView`의 역할은 훨씬 간소화되었고, 자식 컴포넌트들은 부모에 대한 의존성 없이 독립적으로 상태를 갱신하고 다음 단계로 진행할 수 있게 되었습니다. 이러한 개선은 컴포넌트의 재사용성과 유지보수성을 크게 향상시켰습니다.

## 구현 포인트: 견고한 소셜 로그인 계정 처리 로직

소셜 로그인 과정에서 단순히 성공/실패만 처리하는 것은 사용자 경험 측면에서 아쉬움이 많습니다. 예를 들어, 소셜 계정으로 로그인 시도했는데 해당 계정으로 가입된 정보가 없거나, 이미 같은 이메일로 일반 계정이 존재한다면 사용자에게 어떤 안내를 해야 할까요? 이러한 복잡한 시나리오를 효과적으로 처리하기 위해 `composables/social.js`의 `handleSocialLoginFailure` 함수를 대폭 개선했습니다.

**변경 전 (`composables/social.js` 일부)**

```javascript
// socialComposable.js
import { useSessionStore } from "@/stores/session";
import { useRegistrationStore } from "@/stores/registration"; // 아직 socialToken, socialProvider를 직접 관리하지 않음
import { useLoginRedirectHandler } from "@/composables/loginRedirect";
import { useRouter } from "vue-router";

export function useSocialLogin() {
  const router = useRouter();
  const loginRedirectHandler = useLoginRedirectHandler();
  const sessionStore = useSessionStore();
  const registrationStore = useRegistrationStore(); // 이 스토어는 당시 social 데이터를 직접 저장하는 기능이 없었음

  async function handleSocialLoginFailure(provider, token) {
    alert(
      "가입한 계정이 없습니다. 먼저 회원가입 완료 후, 소셜 계정을 연동해주세요"
    );
    // 이전에는 getSocialData를 통해 이메일을 가져와 registrationStore에 저장했지만,
    // 이 시점에서는 이 로직이 삭제되었거나 더 간단했음.
    // 이전 버전의 registrationStore는 socialToken, socialProvider 필드가 없었음.
    await registrationStore.fetchSocialData(provider, token); // 이 함수는 이후 삭제됨
  }

  async function performLogin(provider, token) {
    try {
      await sessionStore.socialSignIn(provider, token);
      await loginRedirectHandler.execute();
    } catch (err) {
      console.error("SignIn With Social Error", err);
      await handleSocialLoginFailure(provider, token); // 단순히 실패 메시지 후 리다이렉트만
    }
  }

  // linkAccount 함수는 isSignup 파라미터가 없었음
  async function linkAccount(provider, token) {
    /* ... */
  }

  return { performLogin, linkAccount, unlinkAccount };
}
```

변경 전 `handleSocialLoginFailure` 함수는 소셜 로그인에 실패하면 단순히 "가입한 계정이 없습니다. 먼저 회원가입 완료 후, 소셜 계정을 연동해주세요"라는 일반적인 메시지를 띄우는 역할만 했습니다. 이 방식은 사용자에게 문제의 정확한 원인을 알려주지 못하고, 적절한 다음 단계를 안내하지 못해 사용자 경험을 저해할 수 있었습니다. 예를 들어, 이미 이메일로 가입된 계정이 있는데 소셜로 로그인하려 한다면, 사용자 입장에서는 혼란스러울 수밖에 없었습니다.

**변경 후 (`composables/social.js` 및 `stores/registration.js` 일부)**

```javascript
// socialComposable.js
import { useSessionStore } from "@/stores/session";
import { useRegistrationStore } from "@/stores/registration";
import { useLoginRedirectHandler } from "@/composables/loginRedirect";
import { useRouter } from "vue-router";
import { SocialApiWrapper } from "@/api/socialApiWrapper"; // 소셜 API 래퍼
import * as validationApi from "@/api/validationCheck"; // 이메일 중복 확인 API
import { useAuthApi } from "@/api/authentication";

export function useSocialLogin() {
  const router = useRouter();
  const loginRedirectHandler = useLoginRedirectHandler();
  const sessionStore = useSessionStore();
  const registrationStore = useRegistrationStore();
  const authApi = useAuthApi();

  async function handleSocialLoginFailure(provider, token) {
    let userEmail = "";
    if (provider === "GOOGLE") {
      const googleUserData = await SocialApiWrapper.Google.getUserInfo(
        provider,
        token
      ); // 구글 사용자 정보 조회
      userEmail = googleUserData.email;
      registrationStore.setSocialToken(token); // 스토어에 social token 저장
      registrationStore.setSocialProvider("GOOGLE"); // 스토어에 social provider 저장
    } else if (provider === "NAVER") {
      const naverClient = await SocialApiWrapper.Naver.initializeCallback();
      const naverUserData = await SocialApiWrapper.Naver.getLoginStatus(
        naverClient
      ); // 네이버 사용자 정보 조회
      userEmail = naverUserData.user.email;
      registrationStore.setSocialProvider("NAVER"); // 스토어에 social provider 저장
      registrationStore.setSocialToken(naverClient.accessToken.accessToken); // Naver token 저장
    }

    // 백엔드 API를 통해 계정 존재 여부 및 충돌 시나리오 검사
    const { data } = await authApi.checkSocialUserStatus(provider, token);
    const {
      email: socialUserEmail,
      existed,
      emailExisted,
      emailVerified,
      nickname,
      birthday,
    } = data.value;

    registrationStore.setSocialProvider(provider);
    registrationStore.setSocialToken(token);

    if (nickname) registrationStore.setNickname(nickname.substring(0, 30));
    if (birthday) registrationStore.setBirthDay(birthday);

    if (existed) {
      // 해당 소셜 계정이 이미 연동된 경우
      window.showAlert({
        desc: "이미 가입한 이메일입니다. 이메일·비밀번호로 로그인하시거나, 다른 이메일로 가입해주세요.",
      });
      router.push("/login");
      return;
    }
    if (emailExisted) {
      // 동일 이메일로 일반 계정 존재 시
      window.showAlert({
        desc: `해당 "${socialUserEmail}"는 이메일로 가입된 계정이에요. [이메일 계정으로 시작하기]를 통해 로그인하신 후, 소셜 계정을 연동해 주세요.`,
      });
      router.push("/login"); // 또는 계정 연동 안내 페이지
      return;
    }
    if (emailVerified === false) {
      // 소셜 계정의 이메일이 미인증 상태
      window.showAlert({
        desc: "이메일 인증이 완료되지 않았습니다. 해당 소셜 사이트에서 이메일 인증 후, SNS 계정 연동을 진행해주세요.",
      });
      return;
    }
    if (!socialUserEmail) {
      // 소셜 제공자가 이메일 정보를 제공하지 않음
      window.showAlert({
        desc: "해당 이메일로 가입할 수 없습니다. support@example.com으로 문의 부탁드립니다.",
      });
      return;
    }

    // 위의 모든 시나리오를 통과했다면, 신규 회원가입 진행
    alert("가입한 계정이 없습니다. 회원가입을 진행해주세요."); // 일반적인 신규 가입 안내 메시지
    registrationStore.setEmail(userEmail);
    router.push(`/signup?registrationType=${provider.toLowerCase()}`);
  }

  async function performLogin(provider, token) {
    try {
      await sessionStore.socialSignIn(provider, token);
      await loginRedirectHandler.execute();
    } catch (err) {
      console.error("SignIn With Social Error", err);
      await handleSocialLoginFailure(provider, token); // 실패 시 상세 로직 호출
    }
  }

  async function linkAccount(provider, token, duringRegistration) {
    // duringRegistration 파라미터 추가
    try {
      await sessionStore.linkSocialAccount(provider, token);
      window.showAlert({ desc: `${provider} 계정 연결에 성공했습니다.` });
    } catch (error) {
      alert(
        `${provider} 계정 연결에 실패했습니다.\n${getDetailMessage(error)}`
      );
    }
    if (duringRegistration) {
      // 회원가입 중 연동을 시도한 경우
      registrationStore.setStep(4); // 가입 완료 단계로 이동
      router.push("/signup?registrationType=NAVER"); // 네이버는 리다이렉트 발생 후 다시 registration으로 돌아옴
      return;
    }
    window.location.href = "/profile"; // 일반적인 연동 완료 후 프로필 페이지로 이동
  }

  return { performLogin, linkAccount, unlinkAccount };
}

// stores/registration.js (일부)
import { defineStore } from "pinia";
import { useStorage } from "@vueuse/core";
import { useAuthApi } from "../api/authentication";
import { useSessionStore } from "@/stores/session";

export const useRegistrationStore = defineStore("registrationStore", () => {
  const email = useStorage("email", "", sessionStorage);
  const password = useStorage("password", "", sessionStorage);
  const marketingAgreed = useStorage("marketingAgreed", false, sessionStorage);
  const nickname = useStorage("nickname", "", sessionStorage);
  const socialToken = useStorage("socialToken", "", sessionStorage); // 새로 추가
  const socialProvider = useStorage("socialProvider", "", sessionStorage); // 새로 추가
  const step = useStorage("step", 1, sessionStorage); // 새로 추가, Pinia로 단계 관리 시작

  const sessionStore = useSessionStore();
  const authApi = useAuthApi();

  // social registration API 호출 시 socialToken, socialProvider 포함
  async function submitRegistration() {
    const { data } = await authApi.registerUser(
      email.value,
      password.value,
      nickname.value,
      marketingAgreed.value,
      null, // birthday 등 다른 필드 (생략됨)
      null,
      null,
      socialProvider.value, // 소셜 프로바이더 정보 전달
      socialToken.value // 소셜 토큰 정보 전달
    );
    sessionStore.setLoginData(data);
  }

  // ... getter/setter 함수들 ...

  function setSocialToken(token) {
    socialToken.value = token;
  }
  function getSocialToken() {
    return socialToken.value;
  }

  function setSocialProvider(provider) {
    socialProvider.value = provider;
  }
  function getSocialProvider() {
    return socialProvider.value;
  }

  function setStep(newStep) {
    step.value = newStep;
  }
  function getStep() {
    return step.value;
  }

  function resetState() {
    // 모든 회원가입 관련 상태 초기화 함수 추가
    email.value = "";
    password.value = "";
    marketingAgreed.value = false;
    nickname.value = "";
    socialToken.value = "";
    socialProvider.value = "";
    step.value = 1;
  }

  return {
    submitRegistration,
    setEmail,
    getEmail,
    setPassword,
    agreeMarketing,
    setNickname,
    getNickname,
    getSocialToken,
    setSocialToken,
    getSocialProvider,
    setSocialProvider,
    setStep,
    getStep,
    getAllData,
    resetState,
    step, // step 상태를 외부에서 접근 가능하도록 노출
  };
});
```

변경 후 `handleSocialLoginFailure` 함수는 소셜 프로바이더로부터 직접 사용자 정보를 가져오고 (`SocialApiWrapper.Google.getUserInfo`, `SocialApiWrapper.Naver.getLoginStatus`), 백엔드의 `checkSocialUserStatus` API를 통해 계정 존재 여부 및 충돌 시나리오를 상세하게 검사하도록 강화되었습니다.

이 함수는 다음과 같은 다양한 시나리오를 처리합니다:

1.  **`existed === true`**: 해당 소셜 계정이 이미 다른 일반 계정이나 소셜 계정과 연동되어 있는 경우. 사용자에게 이메일·비밀번호로 로그인하거나 다른 이메일로 가입하도록 안내하고 로그인 페이지로 리다이렉트합니다.
2.  **`emailExisted === true`**: 동일한 이메일 주소로 일반 계정이 이미 존재하는 경우. 사용자에게 먼저 이메일 로그인 후 계정 설정에서 소셜 계정을 수동으로 연동하도록 유도합니다. 이 프로젝트는 **자동 연동을 지원하지 않고 수동 연동을 정책으로 합니다.**
3.  **`emailVerified === false`**: 소셜 계정의 이메일이 미인증 상태인 경우. 사용자에게 해당 소셜 사이트에서 이메일 인증을 완료한 후 다시 시도하도록 안내합니다.
4.  **`!socialUserEmail`**: 소셜 제공자가 이메일 정보를 제공하지 않는 경우. 지원팀에 문의하도록 안내합니다.
5.  **모두 통과**: 위 시나리오에 해당하지 않는 경우, 새로운 회원가입 플로우를 시작하고 `registrationStore`에 소셜 이메일, 프로바이더, 토큰을 저장하여 회원가입 폼으로 이동시킵니다.

또한, `registrationStore`에 `socialToken`과 `socialProvider` 상태를 추가하고, 이를 관리하는 `setter/getter` 및 `resetState` 함수를 구현하여 소셜 회원가입 플로우의 데이터를 중앙 집중적으로 관리하고, 회원가입 완료 후 상태를 초기화할 수 있도록 했습니다. `submitRegistration` 함수도 `socialProvider`와 `socialToken`을 인자로 받아 백엔드 API에 전달하도록 확장되었죠. 이러한 개선을 통해 소셜 로그인/회원가입 과정에서 발생할 수 있는 거의 모든 예외 상황에 대해 사용자에게 명확하고 친절한 피드백을 제공하며, 불필요한 이탈을 방지하고 회원가입 성공률을 높일 수 있었습니다.

## 사용자 경험을 위한 디테일

사용자 경험(UX)은 기술적인 완성도만큼이나 중요합니다. 저희는 단순한 기능 구현을 넘어, 사용자가 불편함 없이 서비스를 이용할 수 있도록 다양한 디테일을 구현하는 데 신경 썼습니다.

### 실시간 유효성 검증과 Debounce

회원가입 폼에서 이메일이나 닉네임처럼 중복 여부를 확인해야 하는 필드의 경우, 사용자가 입력할 때마다 실시간으로 서버에 API 요청을 보내는 것은 비효율적입니다. 이럴 때 `Debounce`를 활용하여 불필요한 API 호출을 줄이고 사용자에게 부드러운 피드백을 제공했습니다.

```javascript
// EmailForm.vue (일부) - 이메일 중복 확인
import { ref, watch } from "vue";
import { useValidationApi } from "@/api/validationCheck"; // API 래퍼
import { isValidEmailFormat } from "@/utils/emailValidator"; // 유틸리티 함수

const validationApi = useValidationApi();
const emailFields = ref([{ modelValue: "", errMsg: "", successMsg: "" }]);
let debounceTimeout = null;

watch(
  () => emailFields.value[0].modelValue,
  () => {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(async () => {
      const emailValue = emailFields.value[0].modelValue;
      if (isValidEmailFormat(emailValue)) {
        const {
          data: {
            _value: { existed },
          },
        } = await validationApi.checkEmailAvailability(emailValue);

        if (existed) {
          emailFields.value[0].errMsg = "이미 사용중인 이메일 주소에요.";
          emailFields.value[0].successMsg = "";
        } else {
          emailFields.value[0].successMsg = "사용 가능해요.";
          emailFields.value[0].errMsg = "";
        }
      } else if (emailValue.length > 0) {
        emailFields.value[0].errMsg =
          "올바른 형식의 메일 주소를 입력해 주세요.";
        emailFields.value[0].successMsg = "";
      } else {
        emailFields.value[0].errMsg = "";
        emailFields.value[0].successMsg = "";
      }
    }, 500); // 500ms 동안 추가 입력이 없으면 API 호출
  }
);
```

위 코드는 이메일 입력 필드에 `Debounce`를 적용한 예시입니다. 사용자가 이메일을 입력할 때마다 `watch` 함수가 실행되지만, `setTimeout`을 통해 500ms 동안 추가 입력이 없을 때만 `checkEmailAvailability` API를 호출합니다. 이를 통해 불필요한 네트워크 요청을 줄이고 서버 부하를 경감시킬 수 있었습니다. 또한 `errMsg`와 `successMsg`를 통해 사용자에게 즉각적인 시각적 피드백을 제공합니다.

### 사용자 친화적인 에러 메시지 (`showAlert`)

단순한 `alert()` 대신, `showAlert` 함수를 사용하여 통일되고 사용자 친화적인 알림 메시지를 제공했습니다. 특히 API 호출 실패 시 HTTP 상태 코드(예: 400)에 따라 구체적인 오류 설명을 제공하여 사용자가 문제를 명확히 이해하고 다음 단계를 진행할 수 있도록 유도합니다. HTML 태그(`<br/>`)를 활용하여 메시지 가독성을 높이는 것도 작은 디테일이죠.

```javascript
// useAuthApi.js (일부)
import { useAxios } from "@vueuse/integrations/useAxios";
import { apiClient } from "./apiClient";

export function useAuthApi() {
  async function registerUser(
    email,
    password,
    nickname,
    agreeMarketing,
    birthday,
    identityPayload,
    parentalApprovalPayload,
    socialProvider = null,
    socialToken = null
  ) {
    try {
      return await useAxios(
        "/v1/web/sign-up",
        {
          method: "POST",
          data: {
            email,
            password,
            nickname,
            agreeMarketing,
            birthday,
            identityPayload,
            parentalApprovalPayload,
            socialProvider,
            socialToken,
          },
        },
        apiClient
      ).data;
    } catch (error) {
      let message = "회원 가입에 실패했습니다. 잠시 후 다시 시도해주세요.";

      if (error.response && error.response.status === 400) {
        // 백엔드에서 내려주는 400 에러 메시지를 좀 더 구체적으로 사용자에게 전달
        if (error.response.data.code === "EMAIL_ALREADY_EXIST") {
          message =
            "이미 가입된 이메일 주소입니다. 로그인하거나 다른 이메일로 가입해주세요.";
        } else if (error.response.data.code === "INVALID_OTP_CODE") {
          message =
            "입력하신 인증 번호가 일치하지 않습니다.<br/>다시 확인 후 시도해주세요.";
        } else {
          message =
            "입력하신 정보가 올바르지 않습니다.<br/>다시 확인 후 시도해주세요.";
        }
      }

      window.showAlert({
        open: true,
        desc: message,
        onConfirm: () => {
          // 특정 에러 발생 시 초기 페이지로 리다이렉트
          if (
            error.response &&
            error.response.status === 400 &&
            error.response.data.code === "INVALID_OTP_CODE"
          ) {
            // OTP 오류는 현재 페이지에서 재시도 유도
          } else {
            window.location.href = "/";
          }
        },
      });
      throw error; // 상위 컴포넌트에서 추가 처리가 필요한 경우 에러 전파
    }
  }

  // ... other API functions
  return { registerUser /* ... */ };
}
```

API 호출 실패 시, `error.response.status`와 백엔드에서 정의한 에러 코드(`error.response.data.code`)를 기반으로 더욱 구체적인 사용자 메시지를 구성합니다. `showAlert` 함수는 이러한 메시지를 일관된 UI로 사용자에게 제공하여, 오류 발생 시에도 사용자가 당황하지 않고 다음 행동을 결정할 수 있도록 돕습니다.

## 확장 가능한 소셜 로그인 아키텍처 설계 및 보안 고려사항

저희는 현재 구글과 네이버 소셜 로그인을 지원하지만, 미래에 카카오나 애플 등 다른 소셜 프로바이더를 쉽게 추가할 수 있도록 확장 가능한 아키텍처를 염두에 두었습니다.

### 프로바이더 추가를 위한 추상화

`socialApiWrapper.js`에서 각 소셜 프로바이더별 SDK 초기화 및 사용자 정보 조회 로직을 추상화하고, `useSocialLogin` `composable`에서 이를 재사용하는 구조를 구축했습니다. 새로운 프로바이더가 추가될 경우, 해당 프로바이더의 SDK 초기화 및 콜백 처리 로직을 `socialApiWrapper`에 추가하고, 관련 라우터 설정 및 컴포넌트를 생성하는 최소한의 작업만으로 확장이 가능합니다.

이러한 추상화는 `config/socialProviders.js`와 같은 설정 파일을 통해 더욱 유연해질 수 있습니다. 각 프로바이더의 이름, 아이콘, 색상, 제공 정보 등을 정의해두면 UI도 동적으로 생성할 수 있게 됩니다.

### OAuth 보안 강화에 대한 고민

소셜 로그인 시스템의 보안은 아무리 강조해도 지나치지 않습니다. 저희는 현재 구현에서 다음과 같은 보안 고려사항을 인지하고 있으며, 지속적인 개선을 통해 더욱 안전한 시스템을 구축하고자 합니다.

1.  **OAuth `state` 파라미터**: CSRF(Cross-Site Request Forgery) 공격 방어를 위해 OAuth `state` 파라미터 검증이 현재 프론트엔드에서 명시적으로 구현되지 않았습니다. 프로덕션 환경에서는 회원가입 시작 시 무작위 `state`를 생성하여 `sessionStorage`에 저장하고, 콜백 시 이를 검증하는 로직을 반드시 추가해야 합니다.
2.  **PKCE (Proof Key for Code Exchange)**: 특히 모바일 환경에서 `Authorization Code Flow`와 함께 `PKCE`를 적용하여 `authorization code` 가로채기 공격을 방어하는 것이 중요합니다. 현재 저희 시스템의 구글 로그인 흐름은 `Implicit Flow`에 가까우므로, 향후 `Authorization Code Flow with PKCE`로 전환을 고려하여 보안을 더욱 강화할 계획입니다.
3.  **이메일 중복 검사 로직**: 소셜 로그인 시 이메일 중복 검사를 프론트엔드에서 `validationApi.checkEmailAvailability()`로 한 번, 백엔드 `authApi.checkSocialUserStatus()`로 또 한 번 수행하는 이중 검증을 통해 더욱 견고한 유효성 확인을 진행합니다.

## 마치며

이번 프론트엔드 개발 프로젝트는 복잡한 다중 로그인/회원가입 플로우를 효율적으로 설계하고 구현하는 귀중한 경험이었습니다. Pinia를 통한 중앙 집중식 상태 관리, Vue 3 `Composition API`를 활용한 로직 분기, 그리고 다양한 소셜 로그인 시나리오에 대한 견고한 오류 처리 로직은 코드의 가독성과 유지보수성을 크게 향상시켰습니다.

특히, 소셜 로그인 실패 시 발생하는 여러 계정 충돌 상황을 세분화하여 처리하고, 사용자에게 구체적인 안내를 제공함으로써 불필요한 이탈을 줄이고 사용자 경험을 개선할 수 있었다는 점이 가장 큰 보람이었습니다. 아직 `state` 파라미터 미구현이나 `PKCE` 미적용과 같은 개선 과제들이 남아있지만, 이번 경험을 바탕으로 지속적으로 시스템을 발전시켜 나갈 것입니다.

이 글이 복잡한 인증 시스템을 구축하고 계신 다른 개발자분들에게 조금이나마 도움이 되기를 바랍니다. 긴 글 읽어주셔서 감사합니다!

## 참고 자료

- [OAuth 2.0 Simplified](https://oauth.net/2/)
- [Google Identity OAuth 2.0](https://developers.google.com/identity/protocols/oauth2)
- [네이버 로그인 개발 가이드](https://developers.naver.com/docs/login/api/api.md)
- [MDN Web Docs - Debounce](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/debounce)
